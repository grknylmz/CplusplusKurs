////////////////////////////////// C++ Kurs //////////////////////////////////////////
////////////////////////////////// 16.05.2015 ////////////////////////////////////////
Neden C++?
	Verim Kritik
	Multi Paradigm Programlama Tekniği
	Çok fazla kütüphane varlığı -- Qt
	
Farklılıklar
implicit int yok mecburen tür belirtilmek zorunda
C de legal C++ error

int main yaz 



void fonksiyonun geri dönüş değeri olabilir ama ifade void olmak zorunda.
Yani fonksiyonun içerisinde void bi fonksiyonu geri döndürebiliriz.

Veri kaybı otomatik tür dönüşümünde syntax hatası değil.

İlk değer verme
C den farklı olarak T x {exp } c++ 11 le gelen özellik.


int func(){
	double dval = 3.4;   /// İkisindede geçerli
	int ival = dval ;   /// ikisindede geçerli 
	
	
	int ival {dval}; /// Bu syntax de tür dönüşümü syntax hatası değer kaybı engellenebilir.  Narrowing conversion  ilk değer verme syntaxi
		
}
int ival = dval ;

int main(){
	func();
	
	return 0;
}
Aritmetik türden değişkenler çok özel bir durum yoksa tanımlanmalı.

int temp(45);
int temp{45};
int temp = {45};

bunların hepsi C++ da geçerlidir.
Döngü değişkennini döngünün içinde bildirmeye çalış.

Workaround makrosu

Türlere yönelik farklılıklar : 

Bool Mevcut
C++ da bool ve yine C deki gibi int değeri kullanılabilir.







#include <iostream>


using namespace std;

int main(){
	
	cout << typeid(10 > 5).name() << endl;
	cout << sizeof(bool) << endl;
	
}

extern anahtar sözcüğü ile const bir nesneye ilk değer verirseniz dış bağlantı yapılabilir.
const int *ptr = &x; ----> const olan *ptr
int * const ptr = &x; ----> const olan ptr;


#include <iostream>

using namespace std;

int main(){
	cout << "Hello World" << endl;
	
	return 0;

	
}







package dediğimiz kavram c++ da namespace olarak geçiyor.
bir isim alanındaki isimi erişmek için;

neco::X --> ismi neco olan package da ara
:: -> çözünürlük operatörü



#include <iostream>

using namespace std;

int main(){
	int x = 10;
	double dval = 2.3;
	
	
	cout << x << << "    " << dval << "\n";
		
	
	return 0;
}

#include <iostream>

using namespace std;

int main(){
		
	
	return 0;
}

int main(){
	int x,y;
	
	cout << "iki sayi girniniz" ;
	cin >> x >> y;
	
	
	return 0;
}



.a

->b

::x

class Myclass{

public:

private:

protected:


};


struct da heryer public 
class içerisinde değişken.

Sınıfın elemanları:
Data Members        /// Tipik olarak private olarak konulur, protected kalıtım ile devreye girecek
-Static 
-Non Static
Member Functions 
m.func()  // Nesne ile çağırma
ptr->func() // Fonksyion ile çağırma

Sınıfların üye fonksiyonu tekrar bildirilemez

int Myclass::func(){

	myclass::x -----> sadece class scope da arama
	this.x; -----> """"
};




class Myclass{
public:
	void func();
	void foo()const; /// içinde sınıfında veri elemanlarını değiştirmeye çalışmak syntax hatası Getter ?
	////Const elemanlar ile sınıfın sadece const fonksiyonlarını çağırabiliriz.




};



class Myclass{

public:
	****** func(int);
	****** func(int)const; /////Const overloading

	x kendisini const sa const fonksiyon çağırılır değilse normal fonksiyon çağırılır.


};




#include <iostream>
#include <string>
using namespace std;

class Account{
public:

	string getAccountName();
	void transfer(Account &r, double sum);
};

int main(){
	Account necati;
	Account sina;

	necati.transfer(sina,1000);

	return 0;
}



#include <iostream>
#include <string>
using namespace std;

class Account{
	string name;
	double sum;
	mutable int callCounter; ///mutable kullanılarak const fonksiyonuyla çağrılabilir hale getirtilir.

public:
	void display()const;
	
};



void Account::display() const {
	callCounter++;////Sınıfın veri elemanı değiştirilemez
	

}




int main(){
   

	return 0;
}



Sınıfın veri elemanının const üye fonksyionlar değiştirilmesini istiyor isek , mutable anahtar sözcüğü ile tanımlamak zorundayız.
Değişmeyecek bütün veri elemanları için const anahtar sözcüğü kullanılmak zorundadır.

Constructor : :

#include <string>
#include <iostream>



using namespace std;

class Myclass{
	Myclass(); /// Gecerli ctor private olabilir.
public:
	Myclass();
	Myclass(int = 0);
	Myclass(int = 0, int = 0);

};



////CPP


Myclass::Myclass(){
cout << "Myclass::Myclass()" << endl;

}

int main(){

cout << "main baslıyor"<< endl;
cout << "Main bitiyor" << endl;


Myclass *ptr; /////Bu bir pointer, nesne değil o yüzden constructor çağrılmayacak.
Myclass m;
Myclass &r = m; //// Referans constructor ı çağırtmaz aksine isim verilir sadece.

Myclass m(); /// İsmi m olan gdd Myclass turu olan bir işlevin bildirimi.
Myclass m{}; ///C++ 11 le gelen nesne semantiği

cout << "main basladı" << endl;
Myclass x;

}

14.06.2015 Pazar


Constructor sınıfın public non-static inline fonksiyonudur.

Destructor ın ismiyle çaprıldığı tek yer 
// placement new operatörü //
Destructor tanımlamazsak derleyici sınıfa public non static inline kod ekler.

R.A.I.I.

Resource Acquisiton is Initialization
Smart pointer Sınıfları
Dinamik nesne bellekte yer tutmaya devam eder eğer delete edilmezse.


INLINE FONKSİYONLAR
extern c diye belirtiyorduk c'den ' aldığımız kaynak kodlarda.
1- Çok sık çağrılan kodu küçük , ona yönelik çözümlerden biri (C'deki' function like macroya alternatif);

inline int square(int a){

	return a*a;
}


bu inline fonksyionlar başlık dosyalarının içindedirler.
Sınıfın non static üye fonksiyonları , sınıfın static üye fonksyionları , 

friend int func(){
	
}

///////////////////


#include <iostream>

using namespace std;



class Point{

};

int main(){


}


Sınıflara ayırma amacı :
1- Soyutlama yapabilme
2- Kolay değişiklik yapabilme

M.I.L. Member Initialization List
ctor syntaxi 

Bazen sınıfın veri elemanlarına referans vermek zorundayız buna göre bunları MIL syntax ina uygun yapmak zorundayız




Point::Point(double x, double y) : mx(x) , my(y) {        
}


///// Const veya referans elemanlar kullanıyor isek MIL syntax ini kullanmak zorundayız.
///// C++ 11 e kadar ilk değer vermenin tek yolu buydu.


C++ 11 le gelen iki tane çok önemli anahtar sözcük : 
default
delete

/// Operator overloading

Point() = default; ///C++ 11
friend std::ostream &operator<<(std::ostream &os, const Point &r){
	return os << r.mx << r.my << endl;

}           



Sınıf elemanlarına default arguman  atama

class Data{
	int mx = 0;
	int my;
	int mz;
public:
	Data() : my{13} , mz{56}{}
	void display()const{
		cout << mx << my << mz << endl;
	}

};


int int main(int argc, char const *argv[])
{
	Data myData;
	myData.display();
	

	return 0;
}


Başlık dosyasında using bildirimi asla yazılmıcak
Başlık include eder 

Başlıkta örneğin std::string m_name;  tarzında kullanılacak.üü

static std::list<Fighter *> ms_list;
Tanımlamada static anahtar sözcüğü yer almaz. Başlık dosyasında static anahtar sözcüğü kullanılmaz.
Nesneler main çağrılmasından önce construct edilecek.

Named Constructor - İsimlendirilmiş Yapılandırıcı
Kendisi constructor değil ama bir üye sınıfın constructor ı olarak davranıyor.
Öyle durumlar varki client a otomatik veya statik ömürlü oluşturtmak istemiyoruz.
Sınıfa statik bir üye fonksyionu yazarız , private bölüme erişebilir. New olarak erişir.

C++ da new operatorleri nesnenin adresini verir.


//
// Created by Gurkan Yilmaz on 27/06/15.
//

#include <iostream>
#include "Dyna.h"


using namespace std;

class Dyna{
	int mx;
	Dyna(int x): mx{x}{}



public:
	static Dyna *createObject(int val){
		return new Dyna(val);
	}

	void display()const{

	}

};



int main(){
	Dyna *p = Dyna::createObject(45);

	p->display();
	
}


////////////////////////////////////////////////////////


#include <iostream>
#include "Point.h"


using namespace std;


class Complex{
	Complex(double r, double i); /// kartezyen
	Complex(double angle, double distance , int kutupsal); // kutupsal

public:

	static Complex *createCarte(double r, double i){
		return new Complex(r,i);
	}
	
	
	static Complex *createPolar(double angle, double distance , int kutupsal){
		return new Complex(angle , distance , kutupsal);
	}
};






int main(){


	return 0;
}

Singleton ::



Bir sınıf türünden sadece bir nesne olacak ikinci bir nesne oluşturulmasına izin verilmeyecek.
Global access verilecek tüm clientlar bunu kullanabilecek.
Modellediği nesnenin olayı bu. 
İkinci nesne oluşturulamaz. Nesne sayısının artması compile time da tespit edilip hatta öncesinde syntax hatası olarak verilerek beliritilir.


Meyer Singleton Kodu::


class Sina{
	Sina(){}

public:
	static Sina *singleton(){
		static Sina single;
		return &single;
	}
};


int main(){

	auto ptr = Sina::singleton();
	ptr->display();
}

/////////////////////////////


const ve static ise ilk değer verilebilir sınıf içerisinde


class Data{
	static const size_t size = 100;
	static int a[];

public:
	static size_t getsize(){ return ms_size; }  ///static üye fonksiyon const olmaz!!!!!!!!
};

int Data::a[Data::ms_size];



int int main(int argc, char const *argv[])
{
	cout<< Data::getsize()<< endl;
	return 0;
}


//////////////////////////////////////////////////////////////


class Account{
	double m_interest_rate;
	const double m_interest_rate;
	static double m_interest_rate;
	const static double m_interest_rate;


	const static de integral type olmak zorunda !!!!! double float vs olamaz.

public:

};




////////////////////////////////////////////////////////////////

Conversion Constructor:


class Myclass{
	Myclass(int);
public:

	Myclass(int){
		cout<< "Myclass(int)"
	}

};


void func(Myclass m){


}





int int main(int argc, char const *argv[])
{
	Myclass m(456);
	func(78);
	m = 20;




	return 0;
}
//////////////////////////////////////////////////////////////
#include <string>
#include <iostream>

using namespace std;




class Counter{
	Counter();
public:
	Counter();
	Counter(int);

};


void func(const Counter &r);





int main(){
	string s;
	s = "mustafa";
	Counter mycounter;

	//////Counter c(15);
	//////func(c);


	func(15);


	return 0;

}

//////////////////////////////////////////////////////////////


int int main(int argc, char const *argv[])
{
	int ci;
	Counter c;


	func(c);
	return 0;
}



Explicit anahtar sözcüğü:
explicit yazarak dönüşümleri gösterek yapmasını isteriz.
Diğer şekilde implicit yapar ve göstermez cast'i';

Exaxct match
promotion

user defined conversions

Bir standard conversion sonrasında user defined conversion gerekiyorsa derleyici bunu yapar.
Tam tersi yine mümkün.
 

//////////////////////////////////////////////////////////////

using namespace std;



int int main(int argc, char const *argv[])
{
	T a[100]; /// default init.
	T x; ////Default initialization
	T x(10);    T x{10};    /// Value init
	T x = 100 /// Copy init copy constructor çağrılır.

	T x(19);
	T y = 19;  /// explicit olması durumunda error olur.


	string s1("Ali");
	string s2 = "murtaza"; //// Explicit olsa idi syntax hatası

	return 0;
}



En önemli Özellikler C++11 le gelen

1- Move semantiği
2- 
3-
4-
5-


//////////////////////////////////////////////////////////////




class Myclass{

public:
	Myclass(){

		cout << "Myclass :: counstructor" << endl;

	}

	~Myclass(){
		cout << "Myclass :: destructor" << endl;
	}

	void display()const{
		cout << "Myclass::display"<< endl;
	}
};

#include <memory>
using namespace std;

int int main(int argc, char const *argv[])
{
	unique_ptr /// Pointer ın scope u bittiğinde nesne destruct olacak

	Myclass *p = new Myclass();

	p->display();
	delete(p);
	

	///////////




	return 0;
}

void func(unique_ptr<Myclass>); //// Sınıf türünden ise copy init





int int main(int argc, char const *argv[])
{
	cout << "main basladi" << endl;
	{
		unique_ptr<Myclass> ptr(new Myclass);
		ptr->display();
	}

	cout << "Main bitiyor" << endl;

	return 0;
}


//////////////////////////////////////////////////////////////

class Counter{

public:
	explicit operator int()const;

};

Primitive türlerde copy init diye birşey yok.

Operator overloading
// STL'in' temel dayanağı //

T (expr);


static-cast
const-cast
reinterpret-cast
dynamic-cast

//////////////////////////////////////////////////////////////

int main(){
	static_cast<double>(ival) ///Operandı parantez içinde yazmak zorundayız. Syntax zorunluluğu
	const_cast<double>
	reinterpret_cast<double>
	dynamic_cast<double>    ///C'de karşılığı mevcut değil , kalıtımla çalışırken runtime  polymorfizm le alakalı.



}

#include <cstdlib>
#include <ctime>


int int main(int argc, char const *argv[])
{
	dval = static_cast<double>(x)/y;
	return 0;
}





int int main(int argc, char const *argv[])
{
	int x = 10;
	int y = 20;
	double dval;


	dval =static_cast<double> (x)/y; 

	srand((unsigned int)time(nullptr));

	srand(static_cast<unsigned int>(time (nullptr)));




	const_cast<>
	return 0;
}



char *mystrchr(const char *ptr, int ch){
	while(*ptr != '0'){
		if(*ptr == ch)
			return (char * ptr) //// C hali C++ için return (const_cast<char * > ptr)
	}
}


reinterpret_cast ===

int int main(int argc, char const *argv[])
{
	double dval = 2.3;
	char *ptr;



	ptr = char(*)&dval;

	ptr = reinterpret_cast<char*>(&dval);   //// a türünden bir nesnenin adresini b türünden bir nesnenin adresine cast ediyorum. Yani adres sadece
	///// cast edilir.
	return 0;
}



İki ayrı dönüşümün yapılması::::

ptr = reinterpret_cast<char *>(const_cast<double *>(&dval));

Operator overloading ::

Etrafta bir nesne yoksa operator overloading aracının kullanılmasına gerek yok.
Her operator yüklenemez.
nokta operatoru
::
sizeof
? : Koşul operatörü
.*
typeid
overload edilemeyen operatorler


Operator Overload Edilmesi


class Data{
public:

	x.operator>(y);   //// x>y;
	operator>(const Data &r)const;


	!myData
	operator!(const Data &r);
	operator!()const;


	arity  ==== operatorun Unari mi binary mi olması durumuna arity deniliyor.

};


Birden fazla anlama gelen operatorler::

*
&
+
-

static üye operator fonksiyonu olamaz.!!
tum operator fonksyionları ismiyle çağrılabilir.

cout << x 




//////////////////////////////////////////////////////////////



#include <string>
using namespace std::


int main(int argc, char const *argv[])
{
	int ival = 13;

	cout << ival;
	operator<<(cout,ival); /// Global

	cout.operator<<(ival); /// Üye 





	return 0;
}




//////////////////////////////////////////////////////////////



int main(int argc, char const *argv[])
{
	string name1("recep");
	string name2("orhan");

	if (name1 > name2)
		cout << name1 << endl;



	//// if(name1.operator>(name2)) syntax hatası.

	/// Bu şekilde de çağrılabilir.

	if(operator<(name1,name2))
		cout << name1 << endl;



	return 0;
}




//////////////////////////////////////////////////////////////

class Random{
public:
		xxx.operator()();

};

Operatorlerin onceligini degistirmemiz mumkun degildir.


x * y + z Global

operator+(operator*(x,y),z)

Üye Fonksyion
(x.operator*(y)).operator+(z)


int i = 12;
double d = 2.3;

cout << i << d << endl;

((cout.operator<<(i)).operator<<(d)).operator<<(endl)

endl geri donus değeri function pointer 'dır'.






//////////////////////////////////////////////////////////////

class Neco(){

};


Neco operator+(const Neco &r1, const Neco &r2){
	cout << "operator+() cagrıldı " << endl;
}


int int main(int argc, char const *argv[])
{
	Neco n1, n2, n3;

	n1  = n2 + n3;

	return 0;
}


STL''de onemli bir  yer alan iki operator var

operator <
operator ==

Algoritma türden bağımsız template edilmiş fonksiyonlar algoritym kütüphanesi.
#include <set>

using namespace std;

class Neco{

};


int main(int argc, char const *argv[])
{
	set<Neco> myset;
	Neco myneco;

	myset.insert(myneco);
	return 0;
}

//////////////////////////////////////////////////////////////
Friend Bildirimi

Bir sınıf global bir fonksiyona arkadaşlık verebilir.
Bir sınıf bir başka sınıfın bir üye fonksiyonuna arkadaşlık verebilir.


class Neco {
	int mx;
public:
	//friend func(int , int);  /// bir sınıf kendi fonksiyonuna friendlik veremez.


};

int func(int a, int b){
	Neco myNeco ; 
	myNeco.mx = 10;
}

class Gurkan{
public:
	void func();
};




class Neco{
	int mx;
public:
	friend class Gurkan;
};

//////////////////////////////////////////////////////////////


Ön ek Son ek overloading

class Date{

public:
	Date &operator++(); /// Parametre değişkeni olmayan önek
	Date operator++(int);   /// parametre değişkeni olan sonek
int main(int argc, char const *argv[])
{
	Date mydate;
	mydate++;



	return 0;
};

//////////////////////////////////////////////////////////////

Binary simetrik işlemler global operator fonknsyionu ile
Unary işlemler üye operator fonksyionu ile
Olmayan operator overload edilemez
Statik üye fonksyion olamazlar.
Fonksyion çağrı operatoru hariç varsayılan argüman alamaz.
Operatör önceliği değiştirilemez.
İstediğim her fonksyionu global operator fonksyionu oalrak yazamam. global olarak overload edilmez. Üye olmak zorunda.
Operatör fonksiyonuun isimleri keyfi olarak seçilemez .
Operator ++ için dummy int kullanılır.

Const 'luk ' özellikle STL de hata almamıza sebep oolabilir unutulduğu zaman
Ortada bir neden yoksa call by value yapmayın, call by reference yapın.


//////////////////////////////////////////////////////////////
//
// Created by Gurkan Yilmaz on 04/07/15.
//

#pragma once;
class Myint{
	public Myint(int = 0);
	bool operator<(const Myint &)const;
	friend bool operator <(const Myint &, const Myint &);
	friend bool operator <=(const Myint &, const Myint &);
	friend bool operator >(const Myint &, const Myint &);
	friend bool operator >=(const Myint &, const Myint &);
	friend bool operator ==(const Myint &, const Myint &);
	friend bool operator !=(const Myint &, const Myint &);

	friend Myint operator+(const Myint&, const Myint &);
	friend Myint operator-(const Myint&, const Myint &);
	friend Myint operator/(const Myint&, const Myint &);
	friend Myint operator*(const Myint&, const Myint &);
	friend Myint operator%(const Myint&, const Myint &);

	Myint &operator+=(const Myint &r)
	Myint &operator-=(const Myint &r)
	Myint &operator*=(const Myint &r)
	Myint &operator/=(const Myint &r)


	Myint &operator++();
	Myint operator++(int);
	
	Myint &operator--();
	Myint operator--(int);
};


bool operator<(const Myint &, const Myint &);
//  Normal int de çalışmasının sebebi conversion constructor.


C dilinde önek ++ l-value değildir.

C++ l-value'dür'


Tür dönüştürme operatör fonksiyonu

friend Myint operator+(const Myint &r1, const Myint &r2)
{
	Myint retval(r1);
	retval += r2;
	return retval;


	return Myint(r1) += r2;

}


class Myclass{

	operator int()const;
};


operator int()const{ return mval; }
int x;
myintt 


Fraction Sınıfı

fraction.h
#pragma once
#include <iospwd>

class Fraction /// Bir rasyonel sayıyı temsil ediyor. 
{
	Fraction &simplify(); /// Ortak bölenlerinin en büyüğünü bulan bir fonksyiona ihtiyaç var.



public:
	Fraction(int nom = 0, int demom = 1);
	/// F nesnesi dosyaya yazdırılacak -5/7 yazdırırken kesirde olacak eksi
	/// Yazdırırken sadeleştiricek.
	friend bool operator<(const Fraction &r1 , const Fraction &r1); 
	friend bool operator<=(const Fraction &r1 , const Fraction &r1); 
	friend bool operator>(const Fraction &r1 , const Fraction &r1); 
	friend bool operator>=(const Fraction &r1 , const Fraction &r1); 
	friend bool operator==(const Fraction &r1 , const Fraction &r1); 
	friend bool operator!=(const Fraction &r1 , const Fraction &r1); 


	friend Fraction operator+(const Fraction &r1, const Fraction &r2);
	friend Fraction operator-(const Fraction &r1, const Fraction &r2);
	friend Fraction operator*(const Fraction &r1, const Fraction &r2);
	friend Fraction operator/(const Fraction &r1, const Fraction &r2);

	Fraction &operator+=(const Fraction &r);
	Fraction &operator-=(const Fraction &r);
	Fraction &operator*=(const Fraction &r);
	Fraction &operator/=(const Fraction &r);

	Fraction &operator++();
	Fraction operator++(int);
	Fraction &operator--();
	Fraction operator--(int);

	friend std::ostream &operator<<(std::ostream &, const Fraction &);
	friend std::istream &operator>>(std::istream &, const Fraction &);




	static int gcd(int a, int b);
	static Fraction rand();

	int nominator()const;
	int denominator()const;

};


Köşeli parantez operatör fonksiyonu
Fonksiyon çağrı operatör fonksiyonu
İçerik operatör fonksiyonu
Ok operatör fonksiyonu

Köşeli parantez operatör fonksiyonu
Fonksiyon çağrı operatör fonksiyonu
İçerik operatör fonksiyonu
Ok operatör fonksiyonu


/// Köşeli ayraç işlevini yükleyen işlev

Sınıfın üye işleviyle yüklenebilir.
a.operator[](b);
Genellikle bir referans türüne geri döner. Böylelikle işlev çağrı ifadesi doğrudan
bir nesne olarak kullanılabilir.

class Array{
	int *m_p;
	size_t m_size;
public:
	Array(int size = 0 ; int val = 0);
	~Array();
	int operator[](int) const;
	int &operator[](int);
};

Array::Array(int size, int val){
	m_size = size;
	if(m_size == 0){
		m_p = 0;
		return;
	}

	m_p = new int[m_size];
	for(int k = 0 ; k < m_size ; ++k)
		m_p[k] = val;
}

Array::~Array(){
	delete [] m_p;
}

int Array::operator(int index)const{
	return m_p[index];
}


#include <iostream>

int main(){
	Array a(20);
	const Array ca(10,1);
	a[3] = 5;
	// ca[2] = 10; Gecersiz
	std::cout << ca[5] << std::endl;

	return 0;

}


a.operator[](3) = 5;



Fonksyion Çağrı Operatörü Overload
#include <iostream>
using namespace std;

class Distance{
private:
	int feet;
	int inches;
public:
	Distance(){
		feet = 0;
		inches = 0;
	}
	Distance(int f , int i){
		feet = f;
		inches = i;
	}

	Distance operator()(int a, int b,int c){
		Distance D;
		D.feet = a + c + 10;
		D.inches = b + c + 100;
		return D;
	}

	void displayDistance(){
		cout << "F: " << feet << "I:" << inches << endl;
	} 

};


int main(){
	Distance D1(11,10), D2;

	cout << "First Distance";
	D1.displayDistance();

	D2 = D1(10,10,10);
	cout << "Second Distance" ; 
	D2.displayDistance();

	return 0;
}


Köşeli parantez Overload

using namespace std;
const int SIZE = 10;

class safearay{
private:
	int arr[SIZE];
public:
	safearay(){
		int i;
		for(i = 0 ; i < SIZE ; i++){
			arr[i] = i;
		}
	}

	int &operator[](int i){
		if(i > SIZE){
			cout << "Index out of bounds" << endl;
			return arr[0];
		}
	}

	return arr[i];

};



int int main(int argc, char const *argv[])
{
	safearay A;

	cout << "Value of A[2]" << A[2] << endl;
	cout << "Value of A[5]" << A[5] << endl;
	cout << "Value of A[12]"<< A[12]<< endl;
	return 0;
}



Ok operatör fonksiyonu Overload
Üye fonksiyon olmak zorunda return tipi pointer yada nesne olmalı
Smart pointer 
class Ptr{

	X * operator->();
};

#include <iostream>
#include <vector>

using namespace std;
class Obj{
	static int i, j;
public:
	void f() const{cout << i++ << endl; }
	void g() const { cout << j++ << endl; }

};


int Obj::i = 10;
int Obj::j = 12;

class ObjContainer{
	vector<Obj* obj> a;
public:
	void add(Obj* obj){
		a.push_back(obj);
	}

	friend class SmartPointer;
};

class SmartPointer{
	ObjContainer oc;
	int index;
public:
	SmartPointer(ObjContainer& objc){
		oc = objc;
		index = 0;
	}

	bool operator++()//Prefix version
{
	if(index >= oc.a.size())
		if(oc.a[++index] == 0)
			return true;
}

// Overload Operator
Obj* operator->() const{
	if(!oc.a[index]){
		cout << "Zero Value";
		return (Obj*)0;
	}
	return oc.a[index];
}
};




//////////////////////////////////////////////////////////////

#include <>


class Date{
	int m_total_days;
	int m_day, m_mon, m_year;
	static const int mscYearBase = 1700;
	static bool isleap(int y);
	bool isleap()const;

public:
	Date(int d = 0 ,int m = 0 ,int y = 0 );
	//////

	friend bool operator<(const Date &r1, const Date &r2);
	friend bool operator<=(const Date &r1, const Date &r2);
	friend bool operator>(const Date &r1, const Date &r2);
	friend bool operator>=(const Date &r1, const Date &r2);


	Date operator-(int ndays)const;

	friend int operator-(const Date &, const Date &);
	Date &operator++();
	Date operator++(int);
	Date &operator--();
	Date operator--(int);
	operator+=(int ndays);
	operator-=(int ndays);



	Date &setMonthDay(int mday);
	Date &setMonth(int mon);
	Date &setYear(int year);



	////Inserter ve extractorlar

	friend std::ostream &operator<<(std::ostream &, const Date &);
	friend std::istream &operator>>(std::istream &, Date &);

	static Date random();

	int getYear()const;
	int getMonth()const;
	int getMDay()const;
	int getWeekDay()const;  /// 
	int getYearDay()const;
};


throw BadDate();
class BadDate{};

int int main(int argc, char const *argv[])
{
	Date date1;
	Date date2(13);
	Date date3(25,04);
	Date date4(1,1,1998);
	Date.date5 =  Date::random();

	if(date5 > date1){
		date1--;
	}
	else
		date2 = ++date1;

	if(date2 - date3 > 300){
		date1 += 100;
	}

	cout << date2 + 125 << endl;



	return 0;
}


//////////////////////////////////////////////////////////////
İnterface hafif olmalı gerektiğinden dolu olmamalı
//////////////////////////////////////////////////////////////

içerik operatör fonksiyonu 

int main(){

	list<int>::iterator iter = mylist.begin(); ///// geri dönüş değeri list<int>::iterator ? 

	auto iter = mylist.begin();

	İçerik operatörünün operandı yaparsak o konumdaki nesneye erişicel.
	cout << *iter << endl;

	++iter;

	range başlangıç ilk öğe fakat bitiş son+1 . nci öğedir!!!


	for(auto iter = mylist.begin() ; iter != mylist.end() ; ++iter)
		;

	mylist.reverse();





}


İçerik operatörünün overload edilmesi :

Fonksiyonun geri dönüş değeri nesneye dönmesi için geri dönüş değeri referans olmalı.


int main(int argc, char const *argv[])
{
	SmartPtr ptr = new Class;

	(*ptr).display();
	(*ptr).set(346);
	Myclass m{45};
	m = *ptr;




	return 0;
}

Smartpointer'lar' kısmi manada garbage collector işlevinin yerine getirilmesine yardımcı olur.

//////////////////////////////////////////////////////////////
Template'ler'
Şablona dayalı kod yazdırımı


template<typename T, int size>  




template<typename T>   /// T herşey olabilir.
class SmartPtr{
	T *mp;
public:
	SmartPtr(T *p): mp (p);
	~SmartPtr(){
		delete mp;
	}
	T &operator*(){return *mp};
	T *operator->(){return mp};


};


template<typename T>
class List{

};
int main(int argc, char const *argv[])
{
	SmartPtr<Myclass> ptr = new Myclass;
	SmartPtr<string> p = new string;
	list<int> mylist;







	return 0;
}






//////////////////////////////////////////////////////////////
template<typename Key, typename Value>
class Map{

};


int main(int argc, char const *argv[])
{
	Map<int,double> x;

	return 0;
}



template<typename Elem, int size>


class Array{
	Elem a[size];

};



int main(int argc, char const *argv[])
{
	Array<int,30> x;
	return 0;
}

//////////////////////////////////////////////////////////////

using namespace std:
class Myclass{
public:
	bool operator()(int) // unary predicate
};

Predigate sınıf

void operator()(){
	cout << "Myclass::operator()()" << endl;
}

class Random{
	int mlow,mhigh;
public:
	Random(int low, int high) : mlow(low),mhigh(high){}
	int operator()(){return rand % (mhigh-mlow +1) + mlow;}
};



//////////////////////////////////////////////////////////////
using namespace std;
#include <algoritym>

bool isok(int val){
	return val % 5 == 0;
}

template<typename T, class U>
void Countif(,, , , , , , , , U x){
	if( x())
}




class Unpred{
int mx;
public:
	Unpred(int val) : mx{val}{}
	bool operator()(int x){return x % mx == 0; }


};
int main(int argc, char const *argv[])
{
	list<int> mylist;

	srand(static_cast<unsigned>(time(nullptr)));
	for(int k = 0 ; k < 1000 ; k++)
		mylist.push_back(rand());

	count_if(mylist.begin, mylist.end, &isok);

	return 0;
}

//////////////////////////////////////////////////////////////

#include <iostream>
#include <string>
#include <list>
#include <ctime>
#include <cstdlib>
#include <algorithm>

using namespace std;

class Inta{
	int *mp;
public:
	Inta(size_t size) : mp{new int[size]}{

	}; 
	~Inta(){ delete[]mp;}

	////
};

Inta getArray(){
	///,
	int x = 500;
	Inta retval(x);

	return retval;
}


int main(int argc, char const *argv[])
{
	int size;
	cin >> size;

	Inta a(size);

	return 0;
}

int main(int argc, char const *argv[])
{
	Inta myarray = getArray();

	return 0;
}




//////////////////////////////////////////////////////////////

Sağ Taraf referansı taşıma ve mükemmel gönderim de kullanılmak üzere oluşturulmuş bir araçtır.

Atama operatörünün sol tarafına gelen ifadelere sol taraf değeri gelemeyenlere sağ taraf referansı denir.
Adres operatörünün operandı olabilen ifadelere sol taraf referansı , olamayanlar sağ taraf referansı denir.

int x = 20;
int y = 56;

x ve y  l value

x+y R value

345 R value;

func() R value;
&func() --> error


R value ---> &&r
L value ---> &r


------------------------------------------------------------------------------
int &r = 5 // Error

------------------------------------------------------------------------------
int func();

int &r = func(); // Error
------------------------------------------------------------------------------

Sol taraf değeri sağ taraf referansına verilemez.
-------------

int x = 45;
int &&r = x; // Error
int &&r = 56; // Sağ taraf değeri sağ taraf referansına bağlanmış sıkıntı yok.

------------------------------------------------------------------------------

int func();

int &&r = func();

int &func();
int &&r = func(); /// Error 

------------------------------------------------------------------------------

void func (int &r); /// Sol taraf referansı
void func(int &&r); /// Sağ taraf referansı Function Overloading




class Inta{};

void func(Inta &r);
void func(Inta &&r);

---------------------------------------

void func(int &r){
	cout << "L value" << endl;
}
void func(int &&r){
	cout << "R value" << endl;
}


Amaç function overloading de farklılık yaratım Deep copy yapılırken mmove semantiğinin kullanılmasına olanak vermek.
---------------------------------------------------------------------------------------------------------------------

Sağ taraf refenrası seçilerek exact match olur.

using namespace std;


class Myclass{
public:
	Myclass(const Myclass &r);  /// Copy constructor.
	Myclass(Myclass &&r);       /// Move Constructor

};





int main(int argc, char const *argv[])
{
	

	return 0;
}


---------------------------------------------------------------------------------------------------------------------

class Vector{
	int m_size;
	int *m_p;
public:
	Vector(int size) : m_size (size), mp(new int [size]){}
	Vector(const Vector &r) : m_size(r.m_size){
		m_p = new int [m_size];
		for(int k = 0  ; k< m_size; k++){
			m_p[k] = r.m_p[k];
		}
	}
	Vector(Vector &&r) : m_p(r.m_p), m_size(r.m_size){
		r.m_p = nullptr;
	}

};




int main(int argc, char const *argv[])
{
	Vector vec(565);
	vec = getVector();


	return 0;
}

Vector &operator=()


/////////////////////////////////////////////////////////////

Association 
Aggregation Sahiplik
Composition Ömürsel

Araba araba motoru ilişkisi composition -> araba varsa motor var araba yoksa motor yok. /// Ömürsel birliktelik

Bir sınıfın veri elemanını doğrudan başka bir sınıf elemanı olması.
1-Elemanı dpğrudan almak
2-Elemanı conmstructor la alıp destructor la destruck etmek.


//////////////////////////////////////////////////////////////


using namespace std;

class Engine{
public:
	Engine(){
		cout << "Engine::Engine"<< endl;
	}
};


class Car{
	Engine m_e;

};


int main(int argc, char const *argv[])
{
	Engine e;

	return 0;
}


Bir sınıfın tanımı olmadan kullanılması durumuna incomplete type.
ama class Engine *e; pointer ile erişim sonucu error olmaz.

class 











//////////////////////////////////////////////////////////////

#pragma once

class Student{
	std::string m_name;
};


class TeachingGroup{
	std::vector<std::string> mvec;
};


Pointer yada referans olsa idi böyle bir zorunluluk olmayacaktı.
//////////////////////////////////////////////////////////////

#include <vector>
#include <string>

using namespace std;

int main(int argc, char const *argv[])
{
	vector<string> svec;

	
	string s("murat arman");
	svec.push_back(s);
	svec.push_back(move(s));

	return 0;
}

-----------------------------------------------------------


class Member {
public:
	Member &operator=(const Member &){
		cout << "Member::operator(const Member &)" << endl;
		return *this;
	}
};

class Owner{
	Member mem;
};

int main(int argc, char const *argv[])
{
	Owner x, y;
	x = y;

	return 0;
}

class Sina{
public:
	Sina(int);
};

class Myclass{
	Sina mx { 5 };
public: 
};

int main(int argc, char const *argv[])
{
	Myclass a;
	return 0;
}



//////////////////////////////////////////////////////////////
vector<int> Myclass::ivec{100,12};





using namespace std;

class Myclass{
	class StaticData{
		std::vector<int> ivec1;
		std::vector<int> ivec2;
	};
	static StaticData ms_instance;
public:

};

Myclass::StaticData Myclass::ms_instance;
int main(int argc, char const *argv[])
{
	
	return 0;
}

Nested Types

class Myclass{
public:
	typedef int Color;

};

void Myclass::func(){
	Color mycolor;
}

int main(int argc, char const *argv[])
{
	Myclass::Color m;

	return 0;
}

//////////////////////////////////////////////////////////////

class Myclass{
	Color mx; /// İsim aramada bulunamaz Error!
	typedef int Color;
public:
};

class Myclass{
	class Iterator{

	};
	Iterator m_iter;
public:

};
	
------------------------------------------------        
myclass.h

class Myclass{
	class Color;
public:

};

myclass.CPP

class Myclass::Color{
public:
	Color();

};

Myclass::Color::Color();

--------------------------------------------------

myclass.h



class Myclass{

};



//////////////////////////////////////////////////////////////

//// Myclass.h
class Myclass{
	struct Pimple;
	Pimple *mp;
public:
	Myclass();
	~Myclass();
	void display()const;
};


//Cpp

struct Myclass::Pimple{
	int mx, my;
	Pimple() : mx(0),my(0){}
};


Myclass::~Myclass(){
	delete mp;
}

Myclass::Myclass():mp{new Pimple}{}

void Myclass::dislay()const{
	mp->mx;
	mp->my;
}




//////////////////////////////////////////////////////////////

#include <vector>
#include <iostream>


using namespace std;

int main(int argc, char const *argv[])
{
	vector<int>::size_type
	vector<int>::iterator x;

	vector<int>::iterator::iterator_category //// Nested sınıf iterator , Typedef iteratorCategory




	return 0;
}




class Vector{
public:
	class Iterator{
	public:
		typedef int iterator_category;
	};
};


int main(int argc, char const *argv[])
{
	Vector::Iterator::iterator_category
	return 0;
}

Konu Başlıkları
String Sınıfı
Kalıtım 
Ezoterik Araçlar
OOP Genel Araçlar
STL
Dosyalar Giriş Çıkış İşlemleri 


Belki Regex, Smart Pointer, Thread vs.


//////////////////////////////////////////////////////////////

String Sınıfı

typedef basic-string<char> string
String tipi aslında bir typedef ismi
char-traits<char>

String dediğimiz sınıfın tam tür ismi :: 

typedef basic_string<char, char_traits , allocator> string

#include <string> // C++
#include <cstring>// C

using namespace std;

int main(int argc, char const *argv[])
{
	
	return 0;
}
C++ 2011 le beraber Regex kütüphanesi de dahil edildi.
Bazı yazı işlemleri STL algoritym kütüphanesi ile yapılır.
Sınıfın önemli bir bölümü operatör overloading işlemlerinden oluşuyor.

Bazı karışık işlemler STL le kolay bir şekilde halledilebilir.
//////////////////////////////////////////////////////////////
size isimli üye fonksyionu konteynır da tutulan eleman sayısını verir.
string size dersek string in harf sayısını verir.

string::size_type ///İçsel tür // yazının uzunluğunun türü

string::size_type len = s.length();
auto len = s.length();


size_t nin karşılığı aslen string::size_type


string s;

cout << s.size() << endl;
cout << s.length() << endl;
s.empty();   == s.size()


İki fonskiyonda yazının uzunluğunu vermektedir.

//////////////////////////////////////////////////////////////

string s1("mustafa");   //const char * constructor;
string s2 = "gurkan";
string s3{ "mehmet" };  //C++11

string s1(12, 'A');  ///// 12 adet A eklenir.  Bir parametre size_type diğeri char

cout << "(" << s1 << ")" << endl;

 

string s1(s2); /// Copy Constructor



string s('A'); /// boyle bir char parametreli constructor mevcut değil.
bunun alternatifleri    string s1(1,"A");
						string s1("A");

parametresi char olan atama operatör fonksiyonu var ama parametresi char olan string constructor yok.

string s1("Nurettin");
string s2(s1 , 3); /// s1 in 3 indeksinden başlayarak

cout << "(" << s2 << ")" << endl;  //ettin

string s2(s1 , 3 , 2);  // et


char str[100] = "mustafa";

string s1(str); ///const char * lı constructor
string s2(str , 5);  ///char * ve size_type parametreli bir constructor mevcut.



string s1(str+1, str + 5);  //Range based constructor for array

string s1("sina dogru");

string s2(s1.begin , s1.begin() + 4)  /// range based constructor for string container

Initializer List

vector<int> ivec({12 , 45 , 67 , 89 });

string s({ 'a' , 'b' });
s.insert(1, { 'c' , 'a'} );


Listedeki parametrelerin tamamı kullanılıyor.



string func();


string s1("seyfettim");

string s2(move(s1));  ////Move constructor.

string h_em(const string &r);
{
	return "<em>" + r + "/em";
}

Stringi fonksyiona geçerken ideal olan referans göndermek.


#include <list>

int main(int argc, char const *argv[])
{
	list<char> mylist;
	mylist.push_back('c');
	mylist.push_back('a');
	mylist.push_back('n');


	string s(mylist.begin(), mylist.end);


	cout << s << endl;


	return 0;
}


//////////////////////////////////////////////////////////////

string s(120 , 'A' );

cout << s.capacity() << endl;

string s;
string ::size_type cap = 0;
for (int k = 0 ; k < 10000 ; ++k)}
{
	s.push_back('A');
	if(s.capacity() != cap ){
		cout << "size = " << s.size() << endl;
		cout << "capacity" << s.capacity() << endl;
		cap = s.capacity();
		getchar();
	}
}

//////////////////////////////////////////////////////////////

string s;

s.reserve(120);

s[5] = 'A';  //// runtime hatası
//////////////////////////////////////////////////////////////

string s(2345, 'x');

s.reserve(200)  ///Yapılamaz kapasite büyür , kapasite küçülmez.
s.clear(); /// butun elemanları sıfıra çeker.
s.erase(); /// Butun elemanları sıfıra çeker.
s.reserve() //Fonksiyonu çağırılarak kapasite büzülmesi istenebilir fakat garantili değildir.İmplimentasyon kabul ederse olabilme ihtiyacı var.
s.shrink_to_fit();  //Daha garantili 

//////////////////////////////////////////////////////////////

Elemanlara erişmek

[] ve At fonksyionu

string s("orhankaya");


for (int k = 0 ; k < s.size() ; k++ )
	cout << s[k] << " ";

cout << endl;

s[5]  = 'X';
s[8] = 'Z';


cout << s << endl;



s.at(k);  //// Farkı exception throw eder.

exception throw ederken r.what(); fonksiyonu hatanın ne olduğu hakkında bilgi verir.


string s("orhan");
(int) s[s.size()] //// C++11 ile birlikte null karaktere ulaşma garantisi var , at de bu yok.

//////////////////////////////////////////////////////////////


s.front() = 'X'; // C++11   
s.back() = 'X';  // C++11


////begin() , end() iterator donduren islevler
////front() , back() ilk ve son öğreye eriştiren işlevler



cout << s << endl;

return 0; 



npos değeri static const bir veri elemanı string sınıfının

class string {
public:
	const static size_type npos;

};


Statik veri elemanına herzaman :: ile ulaş

string::npos // işaretsiz bir tamsayıdır
string s("murat aksoy");
auto idx = s.find('a');
string size_type idx = s.find('a');

if(idx == string::npos)
	cout << "bulunamadi" << endl;


Bütün arama fonksiyonlarının geri dönüş değeri doğru olması npos 'uyla' alaka
Arama fonksiyonun geri dönüş değeri npos a eşit ise bulunup bulunamamsıdır.



template <typename T , typename U = char_traits<T>, typename A = allocator<T>>
class basic_string{

};

String sınıfının template açılımı

npos arama işlemleri ve geri kalan karakterlerinin hepsinin alınmasında kullanılması.


s.append
s.assign
s.at
s.front
s.back
s.begin
s.capacity
s.cbegin
s.cend
s.clear
s.reverse



string s("murat aksoy");

cout << s[0] << endl;

*s.begin();
*s.end;


string::iterator iter1 = s.end();
string::iterator iter2 = s.begin();



int main(int argc, char const *argv[])
{
	string s("recepmutlu");
	sort(s.begin,s.end); //kucukten buyuge sorgular

	cout << s << endl;
	cout 
	return 0;
}



int main(int argc, char const *argv[])
{
	vector<string> svec{"orhan" , "necat", "emre" ,"ozkan"};

	sort(svec.begin(),svec.end()
	return 0;
}




*max_element(s.begin(),s.end())  max element iterator dondurmekte dondurdugu elemana erişmek için içerik operatörünü kullanmak gerekir.
okuma amaçlı yapılan işlemlerde 
cbegin
cend fonksiyonları kullanılabilir.
rbegin
rend fonksiyonları algoritmaların sondan başa doğru çalıştırılmasına izin veriyor.





reverse iterator  aracı ile algoritmaları kullanırken tersten yazdırabiliriz.

using namespace std;

template <typename Iter>
void DisplayRange(Iter beg, Iter end){
	while (beg != end)
		std::cout << *beg++;
	std::cout << endl;
} 


int main(int argc, char const *argv[])
{
	/* code */
	return 0;
}


s.substr() // Parametresiz hali stringin tamamını döndürmektedir.
s.substr(8) //8. elemandan itibaren kalan bütün char lar







int main(int argc, char const *argv[])
{
	string filename;

	cout << "dosya ismi:";
	cin >> filename;

	auto idx = filename.rfind('.');

	if(idx == string::npos){
		cout << "dosya uzantisi yok" << endl;

	}



	else{

	}
	return 0;
}


Resize container larda kapasiteyi değil karakter kapasitesini ayarla.


int main(int argc, char const *argv[])
{
	string s("ali");

	s.resize(8 , 'x');

	s.resize(2);  /// Kucultme islemi


	return 0;
}


lexicographical_compare

container compare

karşılaştırma operator fonksyionlarının char paramtresi yok.


string name{"necatiergin"};
name.compare(3, 3, "atil" , 3);


insert fonksiyonu
Geri dönüş değeri insert edilen fonksiyonun yeri


svec.insert(svec.begin , "murat");


index ile set edilen nesnelerin ger dönüş değeri stringin kendisini



string s1{"gurkan"};
string s2{"xyz"};

s1.insert(3 , s2);   ////gurkxyzan
s1.insert(s1.begin(), 10 , 'x');

.erase( iterator ) O konumda olan elemanı siler.
.erase( beg , end) o aralıktaki elemanları siler.

stringleri silme:
string s{"recepmutlu"};
s="";
s.resize(0);

s.erase(s.begin()+ 3 , s.begin +5);
Replace fonksiyonu

Data fonksiyonu

#include <string.h>


using namespace std;
int main(int argc, char const *argv[])
{
	int x;
	string base{"image"};

	to_string() fonksiyonu ile stringe istenilen tür çevrilebilir.

	return 0;
}

Yazının içinden tamsayıyı çekmek

int main(int argc, char const *argv[])
{
	string s("2345Ali");
	size_t uval;


	auto x = stoi(s, &uval);
	cout << x << endl;
	cout << uval << endl;

	return 0;
}


Inheritance ( Türetme )

necatiergin2013@gmail.com 

Private ve protected türetmesi

Public türetmesi -> is-a türetmesi

incomplete type dan türetme olmaz , derleyici complete type ini görerek türetme yapar. Bir sınıf kendisinden doğrudan türetilemez.



//////car.h
class Car{

};

class Bmw : public Car{  //// Türetme

};



Türetmede hiçbir anahtar sözcük kullanılmazsa (public kullanımaz ise mesela) yine türetme yapılabilir. Ama private türden olur.


class Base{
public:
	void f1();
	void f2();
};

class Der : public Base{
	int mz, mt;
public:
	void f3();
	//// Der sınıfının 3 tane fonksiyonu var.

};


int main(int argc, char const *argv[])
{
	Der myder;
	myder.f1();
	myder.f2();
	myder.f3();


	return 0;
}




int main(int argc, char const *argv[])
{
	Employee *emp;
	SalesManager *smp = static_cast<SalesManager *>(emp);


	smp->func();


	return 0;
}


class Base{
public:

};

class Der  : public Base{
public:

};

int main(int argc, char const *argv[])
{
	Der myder;
	return 0;
}




class Manager  :  public Employee{
public:
	using Employee::Employee; ///C++11 ile gelen inherited constructor, constructor ı yazma görevini artık bu koda veriyoruz.

};




class Base{
	int mx;
public:
	Base(int x): mx{ x }{} 
};

class Der : public Base{
public:
	using Base::Base;
};


int main(int argc, char const *argv[])
{
	Der myder(10);
	return 0;
}



Destructorlar ve inheritance:

1. Runtime Polymorphism 
2. Data Abstraction

Data Abstraction (Elamanları gizle, interface i ayır , client kodlar işi yapsın , problem domanindeki varlık kolayca kullanılabilsin.)  - Inheritance (Kalıtım , kod tekrarırının 
	önlenmesi , public interface alınarak türetme yapıyoruz.) - 


}



class Base{
public:
	Base(int);
	Base(double,double);
};

class Der : public Base{
	using Base::Base;
};


Bizim yazdığımız constructor 'ın' inherited constructor a göre önceliği mevcut.
Varsayılan argüman inherit edilmiyor. //Const expr önemli

Using Keyword'unun' kullanıldığı durumlar :

using namespace std; /// Namespace bildirimleri.
yada
using std::cout;




typedef int Word;  --> C++11 öncesi ve C

Typedef 'in' using bildirimi ile yapılması

using Word = int;  /// Using ile typedef 
using Fptr = int(*)(int , int);

Bazı işlemler eski typedef le yapılamazken C++11 ile gelen using kullanımı daha fazla hareket kabiliyetine sahip.
Türemiş sınıfın kendi scope una dahil edilme olayı using bildirimi ile yapılabilir.


class Base{
public:
	void func(int);
};

class Der : public Base{
public:
	void func();

};


int main(void)
{
	Der myder;

	myder.func(); ///Gecersiz
	myder.Base::func();

	return 0;
}


Maskelemenin aşılamadığı tek yer iç blok dış blok maskelemesi


class Base{
public:
	void func(int);
};

class Der : public Base{
public:
	void func();
	using Base::func();  /// Using in üst sınıfda kullanımı.

};


int main(void)
{
	Der myder;

	

	return 0;
}

using 'in' inherited constructor ile kullanımı

class Base{
public:
	Base(int);
};

class Der : public Base{
public:
	using Base::Base();
};


////////////

class Base{
public:
	Base(){
		cout << "Base::Base()" << endl;
	}
	Base(const Base &){
		cout << "const Base &" << endl;  ///Copy Constrctor.
	}
};



class Der : public Base{
	Der(){}
	Der(const Der &r) : (Base (r)){   ///Copy Constructor.

	}
};


int main(int argc, char const *argv[])
{
	Der d1;
	Der d2(d1);  /// Burada copy constructot çağrılır.

	return 0;
}


Türemiş sınıf için copy constructpr yazılırken , taban sınıfın copy constructor ının çağrılması için çağrılması gerekir. Eğer derleyiciye bırakılırsa bu iş default constructor
çağrılır.

Atama Operator Fonksiyonu : 


class Base{
public:
	Base &operator=(const Base &r){
		cout << "Base::Base(const Base &r)" << endl;
		return *this;
	}
};


class Der : public Base{
public:
	Der &operator=(const Der &r){
		cout << "Der::operator=(const Der &r)" << endl;
		Base::operator(r);
		return *this;      //// Veya şu şekildede yazılabilirdi ((Base *)this)->operator=(r); // Doğru ama gereksiz.

	}

};

int main(int argc, char const *argv[])
{
	Der d1,d2;

	d1 = d2;

	return 0;
}




///////////////////////////////////


using namespace std;
class Base{
public:
	static void sfunc();

};


class Der : public Base{
public:

};


int main(int argc, char const *argv[])
{

	Der::sfunc();
	Base::sfunc(); 

	/// static sfunc iki şekildede çağrılabilir.
	



	Der myder;
	Base &r = myder;

	r.sfunc();   //// Base in sfunc() ı çağırılır.


	return 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																Runtime Polymorphism Çalışma Zamanı Çokbiçimliliği


class Employee{
public:
	void display()const{
		cout << "I am an Employee" << endl;
	}
};


class Manager : public Employee{
	void display()const{
		cout << "I am an Manager" << endl;
	}
};


class Driver : public Employee{
	void display()const{
		cout << "I am an Driver" << endl;
	}
};


class Cook : public Employee{
	void display()const{
		cout << "I am a Cook" << endl;
	}
	
};




int main(int argc, char const *argv[])
{
	Manager m;
	m.display();

	Manager m;
	Driver d;
	Cook c;

	Employee *ptr = &m;
	ptr->display(); /// İsim arama employee 'de' yapılcak çağrılan fonksiyon Employee 'nin ' fonksyionu olucak.


////Virtual eklendiğinde kimin nesi kullanılırsa onun fonksiyonları gelmekte.

	return 0;
}






#include <ctime>

void func(Employee *ptr){
	ptr->display();
}

int main(int argc, char const *argv[])
{
	srand((unsigned)time(nullptr));

	for(; ;){
		switch(rand() % 4){
			case 0: cout << "Case Manager" <<endl; func(new Manager); break;
			case 1: cout << "Case Driver" <<endl; func(new Driver); break;
			case 2: cout << "Case Cook" <<endl; func(new Cook); break;
		}
		getchar();

	}

	return 0;
}

C++ 'da' new anahtar sözcüğünün geri dönüş değeri adrestir.

Fonksyiona ne gönderirsen artık fonksiyon ona göre çalışmaya başlayacak Runtime Polymorphism sayesinde.



class Airplane{  //// Polymorphic sınıf.
public:
	void func();
	virtual void foo(); /// Virtual function
	virtual void g() = 0;  /// 0 olması gerekiyor abstract metodlar kullanılırken. Bunun imlementasyonu null. Pure virtual function
};


Virtual olmayan fonksyionun override edilmesi gibi durum söz konusu değil.
Virtual keyword ü sadece bildirimde yer alacak. Taban sınıfın bir sanal fonksiyonunu override edebilmek için öyle bir fonksiyon blidirilicekki geri dönüüş değeri ve parametrik
yapısı aynı olmak zorunda.


Virtual fonksiyonla aynı imzaya sahip farklı geri dönüş değerli *error* 
Eğer tabanın fonksiyonu ezilmişse override edilmiş fonksiyon çağrılır.
Static üye fonksyinlar virtual olamaz. Destructor sanal olur.


Sanallık mekanizmasının devreye girmeme durumları : 


int main(int argc, char const *argv[])
{
	Manager m;
	Employee e;

	e = m;   ///    Object slicing büyük bilgili elemanı küçüğe atama durumu 


	return 0;
}



	Taban sınıf nesnesi yolu ile sanallık mekanizması devreeye girmez.
	Referans yada pointer yolu ile atama yapılmalı.  Eğer abstraction özellikleri kullanılmak istenirse.

	Static Binding veya Early Binding      ||       Dynamic Binding veya Late Binding








	void func(Employee *ptr){
		ptr->vfunc();
	}

	vptr -> virtual table pointer Sanal fonksiyon tablosu diye runtime in başlangıcında bir veri yapısı oluşturuyor. vtable indexleri mevcut , bu indekslere karşılık
	sanal fonksiyonun adresleri mevcut. bütün sanal fonksiyon elemanlarının adresleri bu tablolarda tutuluyor. 

	Maaliyeti 2 kere indirection işlemi mevcut İşlemci Maaliyeti
	Her nesne için bir pointer olması bellekte maaliyet yaratır. 
	

	class Shape{
	public:
		virtual void draw();

	};


	class Triangle : public Shape{
	public:
		int draw();  //// Syntax hatası
	};


	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////


	class Shape{
	public:
		virtual void draw();
		void falanca(int);
		int foo(int);

	};


	class Triangle : public Shape{
	public:
		virtual void draw(int);  //// Artık draw yeni bir fonksyion tanımlanması
	};

	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////
	class Shape{
	public:
		virtual void draw(int);
	};

	class Square : public Shape{
	public:
		void draw(int)override;  //// Override anahtar sözcüğü

	};

	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////

	contextual keywords : Bağlama ilişkin anahtar sözcük ( override , final )


	class Myclass final{

	}; /// Artık bu sınıftan türetilme yapılmasın error

	class Base{

	};


	class Der final : public Base{
		//// artık Der sınıfı türetilemez final anahtar sözcüğü olduğu için.
	};

	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////


	class Base{
	public:
		virtual void func()const;
	};

	class Der : public Base{
	public:
		virtual void func()const override final;
	};

	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////

	class Base{
	public:
		virtual void vfoo();
		void func(){
			cout << "Base::func()" << endl;
			vfoo();
		}

	};


	class Der : public Base{
	public:
		virtual void vfoo()override{
			cout << "Der::vfoo" << endl;
		};
	};

	int main(int argc, char const *argv[])
	{
		Der myder;

		myder.func();
		return 0;
	}


	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////

	Constructor içinde yapılan sanal fonksiyon çağrıları sanal fonksiyonlara bağlanmaz!
	Sanallık durumu nerelerde devreye girmez
	Taban sınıf nesnesi ile devreye girmişse
	Constructor ve destructor kullanımında 
	Çözünürlük operatörü çağrısıyla yapılırsa devreye girmez


	Virtual Destructor
	Taban sınıfın destructor ını virtual yapmalıyızz. Türemiş sınıf nesnesini taban sınıf pointer ıyla delete ederken virtual etmemiş olursak türemiş sınıfın destructor
	ı çağrılmıyor.

	Destructor sanal olabilir mi ? Polymorphic sınıflarda destructor lar herzaman sanal olmalı.

	Constrcutor sanal olabilir mi ? 

	class Employee{
	public:
		virtual ~Employee() = default;
		virtual Employee *createSimilar()
		{
			return new Employee;
		}
		virtual string getName()const{
			return "Employee";
		}
	};

	class Manager : public Employee{
	public:
		virtual Employee *createSimilar()override{
			return new Manager;
		}

		virtual string getName()const override{
			return "Manager";
		}

	};


	class Driver : public Employee{
	public:
		virtual Employee *createSimilar()override{
			return new Driver;
		}

		virtual string getName()const override{
			return "Driver";
		}
	};


	class Accountant : public Employee{
	public:
		virtual Employee *createSimilar()override{
			return new Accountant;
		}

		virtual string getName()const override{
			return "Accountant";
		}
	};


	class Cook : public Employee{
	public:
		virtual Employee *createSimilar()override{
			return new Cook;
		}
		
		virtual string getName()const override{
			return "Cook";
		}
	};

	void chatRoom(Employee *ptr){

	}

	int main(int argc, char const *argv[])
	{
		

		Employee *pnew  = ptr->createSimilar();


		srand (static_cast<unsigned>(time(nullptr)));
		switch(rand() % 4){
			case 0: cout << "Manager case" << endl; chatRoom(new Manager); break;
			case 1: cout << "Driver case" << endl; chatRoom(new Driver); break;
			case 2: cout << "Accountant case" << endl; chatRoom(new Accountant); break;
			case 3: cout << "Cook case" << endl; chatRoom(new Cook); break;
		}
		return 0;
	}


Double Dispatch

class Car{
public:
	virtual ~Car();
};



class Opel : public Car{
public:

};


class Mercedes : public Car{
public:
	
};


class Bmw : public Car{
public:
	
};


void  game(Car *p1 , Car *p2){

}





int main(int argc, char const *argv[])
{
	
	return 0;
}




	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////	/////////////////////


class Employee{
public:
	virtual void vfunc(); 
};

void gfunc(Employee *ptr){
	ptr->vfunc();
}

class Manager : public Employee{

};

int main(int argc, char const *argv[])
{
	
	return 0;
}

Soyut sınıfları pointer veya referans ile kullanımı mümkün.


class Car{
public:
	void start();
	virtual void run();
	virtual void accelerate() = 0 ;  /// bunun implementasyonu yok içi boş !! Bump bump bump
};

Artık Car sınıfı abstract bir sınıfıtr.

int main(int argc, char const *argv[])
{
	Car myCar; /// Abstract sınıftan eleman oluşturulamaz.
	///Soyut sınıflar türünden nesneler oluşturulamaz.
	
	return 0;
}

Templates::                                             

class Template vs Template class

function Template vs Template function

//Angular bracket
//Template parameter - template type parameter
Template sabit parametresi

Nontype parameter lar da mevcut. Derleyicide sabit kullanma emri veriyor.
Variadic template aracı 2011 den itibaren templatelere gelmşitir.


template <typename T , typename U , typename K , int a>  

template <typename T>

void swap(T &r1 , T&r2)

Derleyici derleyemezse composile time error olur
Template argument deduction.


Bir şablondan oluşan fonksyiona çağrı yaptığımızda derleyici argümanlardan aktarılan parametrelerin ne olduğunu anlmya çalışır.
;

template<class T>
void func(T x, T y){

}

int main(int argc, char const *argv[])
{
	int x = 10, y= 20;

	func(x,y);


	return 0;
}

ayrı türlerin aynı template türlerine gönderilmesi sonucu ambiguity oluşur.


void func(T x){
	cout << typeid(T).name() << endl;
}

class Myclass{

};

int main(int argc, char const *argv[])
{
	Myclass m;

	func(&m); // (T *ptr) içim Myclass


	return 0;
}



void func(T &x) için 
int a[10] = {0}; ın T si int türünden 10 elemanlı bir dizidir. int [10]



expilicit olarak template tür parametreisi yazılımı ;

func<int>();




template<typename T>
T getmax(const T *p , size_t size){
	T max(*p);
	for (size_t i = 0; i < size; ++i)
	{
		if( p[k] > max )
			max = p[k];
		return max;

	}
}






 //////////////////////// //////////////////////// //////////////////////// //////////////////////// ////////////////////////


template<typename T> 
void display(T &x){
	for(int k = 0 ; k < sizeof(x) / sizeof(*x) ; ++k )
		cout << x[k] << endl;

}





int main(int argc, char const *argv[])
{
	int a[10] = {1, 2, 4, ,5,2, 3, 7 ,6, 8, 10};
	int b[5] = {1 , 3 , 5 , 7 , 9};
	display(a);	
	display(b);



	return 0;
}




template <typename T>
void func(int (*fp)(T)){
	cout << typeid(T).name() << endl;
	cout << typeid(fp).name() << endl;

}



using namespace std;

template<class T>
void func(T x){
	cout << "template function" << endl;
}

void func(int x){
	cout << "nontemplate function ... func(int)" << endl;
}

int main(int argc, char const *argv[])
{
	func(10.5);
	func(34);
	func(5u);

	///Explicit template argument kullanılır ise;


	func<int>(10);
	return 0;
}




19.09.2015 C++
Iteratorler

Konum bilgisi tutan smart pointerlara sahip containerlar

template<typename Iter>
void algo(Iter beg, Iter end){ ///Beg dahil end hariç iteratorler konusunda hiçbir kontrol yapmamakta.
	while(beg != end){
		*beg = 

		beg++;

	}
}

Hiçbir algortima hiçbir konteynıra eleman ekleyemez  , eleman silemez. 
O kontrol konteynıra atil.
Neden birsürü remove algoritması var ? 


int main(int argc, char const *argv[])
{
	vector<string> svec{"ali" , "veli" , "hakan" , "selami" , "tuncer"};
	reverse(svec.begin() , svec.end());

	for(auto &x ; svec)
		cout << x << "";


	list<string> svec{"ali" , "veli" , "hakan" , "selami" , "tuncer"};
	for(auto &x : slist)
		cout << x << " ";

	cout << endl;



	return 0;
}



using namespace std;

using Con = vector<int>;
using Iter = Con::iterator;

int main(int argc, char const *argv[])
{
	cout << typeid(Iter::iterator_category).name() << endl;


	return 0;
}

input iterator
*iter
iter->
iter1 != iter2
++iter
iter++


output iter
*iter
iter->


vector array strşng deck -> random acces iterator kategorisine sahip

int main(int argc, char const *argv[])
{
	list <int> mylist(129);
	sort(mylist.begin() , mylist.end()); //Compile time hatasına sebep olur


	return 0;
}


Copy algorithm

temolate<typename InIter, typename OutIter>
OutIter Copy(InIter beg, InIter end, OutIter destbeg){
	while (beg =! end)
		*beg++ = *destbeg++;
	return destbeg;
}

int main(int argc, char const *argv[])
{
	list<int> mylist{12, 34, 65, 1 , 5 ,9 , 3};
	vector<int> myvec(7);

	Copy(mylist.begin(), mylist.end(), myvec.begin());

	for(auto &x : myvec){
		cout << x << " ";
	}





	return 0;
}



cupa.h


#include <algorithm>

template<typename C, typename F>   ///Countainer - Funcdir
void fc(C &c, size_t n, F f){
	std::generate_n(std::inserter(r, r.begin()), n, f);
}


template<typename C>
void display(const C &c){
	for(auto &r : c)
		std::cout << r << " ";
	std::cout << std::endl;
}


void randomize(){
	srand(static_cast<unsigned>(time(nullptr)));
}

template<typename InIter>
void display(Initer ge, Initer end){
	while (beg != end )
		std::cout << *beg++ << " ";
	std::cout<< "\n" << std::endl;

}

std::string rs();
std::ostream sl(std::ostream &);




/////main
int main(int argc, char const *argv[])
{
	randomize();

	vector<int> ivec;

	fc(ivec, 100, rand);
	fc(ivec, 100 , [](){return rand() % 1000});

	return 0;
}

Find algoritması

int main(int argc, char const *argv[])
{
	randomize();
	list<string> mylist;
	fc(mylist, 100, rs);
	display(mylist);

	string sval;

	cout << "aranacak ismi girin: ";
	cin >> sval;

	auto iter = find(mylist.begin(), mylist.end() , sval);
	if(iter == mylist.end()){
		cout << "bulunamadı" << endl;
	}
	else{
		cout << "bulundu" << endl;
	}


	return 0;
}



bool isOk(const string &r){
	return r.size() == 7;

}
predicate bool donduren fonksiyonlardır.
tek parametreli unary predicate
iki parametreli ise binary predicate


int main(int argc, char const *argv[])
{
	randomize();
	list<string> slist;

	fc(slist, 100, rs);
	display(slist);
	vector<string> svec;
	char c;

	cout << "bir karakter girin : ";
	cin >> c;
	int n;

	cout << "kacıncı karakter";
	cin >> "n";

	copy_if(slist.begin(), slist.end(), back_inserter(svec) , [=](const string &r){return r[n] ==c;});
	display(svec);




	return 0;
}



****************************************************************************************************************

template <typename Iter>
void Advance(Iter &r, int n, std::random_access_iterator_tag){

}
template <typename Iter>
void Advance(Iter &r, int n, std::bidirectional_iterator_tag){
	
}


template<typename Iter>
void Advance(Iter &r, int n){
	Advance(r, n, typename Iter::iterator_category());   /// Bu türden geçici nesne yaratma syntax i
}


int main(int argc, char const *argv[])
{
	
	return 0;
}




****************************************************************************************************************

#include <iterator>
using namespace std;

template<typename C, typename T, typename D = ptrdiff_t , typename P = T * , typename R = T&>
struct Iterator{
	typedef C iterator_category;
	typedef T value_type;
	typedef D difference_type;

};

int main(int argc, char const *argv[])
{
	iterator<>
	return 0;
}



////  C++ template metaprogramming Conceptes Tools Techniques David Abragam Aleksey Gurtovoy

using Iter = list<Myclass>::iterator;
class Myclass{};
int main(int argc, char const *argv[])
{
	return 0;
}




template<typename Iter> 
struct Iterator_traits{
	typedef typename Iter::iterator_category iterator_category;
	typedef typename Iter::value_type value_type;
};

template<typename Iter>
void algo(Iter beg, Iter end){
	typename Iterator_traits<Iter>::value_type;
}

template<typename T>
struct Iterator_traits<T *>{
	typedef T value_type;
};


****************************************************************************************************************

int main(int argc, char const *argv[])
{
	list<int> mylist(10);

	vector<int> myvec;

	copy(mylist.begin() , mylist.end(), back_inserter(myvec));


	return 0;
}




T *ptr ->interface yazma fonksiyonu
const T* ptr -> okuma fonk.

Algoritmaların template tür parametreleri : 
vector<int> iterator template argument deduction da const semantiğini nasıl sağlarız ? 

const Iter x; -> sınıf nesnesinin kendisi const olur.
Bizim ihtiyacımız *iter in constluğu yani içeriğin constluğu
 


 int main(int argc, char const *argv[])
 {
 	list<string> mylist;

 	randomize();

 	fc(mylist, 20 , rs);

 	display(mylist);

 	list<string>::const_iterator iter = mylist.begin();
 	*iter = "selami";

 	auto iter = mylist.cbegin(); /// C++11 ile geldi auto şekliyle iterator ün const edilmesi durumu.





	list<string>::iterator iter = find(mylist.begin() , mylist.end() , [](const string &r){return r.size() >= 3; });




 	return 0;
 }
 ****************************************************************************************************************

template<class Iter>
void put<Iter beg, Iter end>
{
	while (beg != end)
		std::cout<< *beg++ << " ";
	std::cout<< std::endl;

}




int main(int argc, char const *argv[])
{
	begin(mylist); //buradaki amaç  ? normal diziler için kullanabilmek için bu şekilde bir fonksiyon getirilmiştir.

	int a[100] = {0};

	begin(a);


	return 0;
}



Itereator , reverse iterator , const iteratore , cbegin .


****************************************************************************************************************


int main(int argc, char const *argv[])
{
	randomize();

	list<string> mylist;
	fc(mylist,10 , rs);

	display(mylist.begin(), mylist.end());

	display(mylist.rbegin(), mylist.rend());

	///Hepsi 2011 öncesinde mevcuttu.

	
	return 0;
}


Algoritmalar:


for each algoritması::
template<class Iter , class F>
F For_each(Iter beg, Iter end, F f){
	while(beg != end)
	f(*beg++);
	
	return f;
}

For_each(mylist.begin(), mylist.end() , [](const string &){cout << r << " ";});
Sonunda copy olanlar o haliyle kopyalayıp başka bir yere gönder.

remove copy kopyala ve sil.

****************************************************************************************************************

int main(int argc, char const *argv[])
{
	string name;
	cout << "İsim girin." ;
	cin >> name ;

	remove_copy(mylist.begin(), mylist.end(), back_inserter(myvec), name);
	display(myvec);

	return 0;
}

bool isWowel(char c){
	c = toupper(c);
	return c == 'A' || c == 'E' || c == 'I' || c == 'U' || c == 'O';
}

remove copy if --> bi koşula uyanları silip kopyalayacak.

remove_copy_if(mylist.begin(), mylist.end(), back_inserter(myvec) , [](const string &r){return !(isWowel(r[0]) && isWowel(r.back));});
display(myvec);


****************************************************************************************************************
int main(int argc, char const *argv[])
{
	mylist.erase(mylist.begin());
	mylist.erase(--mylist.end());

	string name;
	cout << "isim girin : ";
	cin >> name;

	auto iter = find(mylist.begin(), mylist.end(), name);
	if (iter == mylist.end())
	{
		cout << "bulunamadı\n"
	}
	else{
		mylist.erase(iter, mylist.end());
	}

	display(mylist);
	return 0;
}


****************************************************************************************************************

Removing algorithm --> STL'de'ki silme algoritmalar:
Gerçek silme değil logic silme gerçekleştiriyor.

remove ile silinme yok.
erase ile silinme yapılabiliyor.

int main(int argc, char const *argv[])
{
	list<int> mylist;
	fc(mylist, 30 , [](){return rand() % 5 ;});
	display(mylist);


	int val;
	cout << "Bir sayı giriniz";
	cin >> ival;

	auto iter = remove(mylist.begin(), mylist.end(), ival); // Enson silinmesi gereken değerden sonraki eleman
	cout << "size" << mylist.size() << endl;
	display(mylist.begin , iter);

	mylist.erase(remove(mylist.begin(), mylist.end(),iter), mylist.end());


	return 0;
}

Fiziksel silme yapmak gerekiyor ise ?

int main(int argc, char const *argv[])
{
	vector<string> myvec;
	fc(myvec, 100, rs);
	display(myvec);
	
	char c;

	cout << "Bir harf girin." ;
	cin >> c;

	/// remove if , container array fonksiyonu , lambda 
	predicate
	Container 'da ' tutulan öğe türünden gönderiliyor.

 	svec.erase(remove_if(myvec.begin(), myvec.end(), [=]( const string &s ){ return s.find(c) != string::npos }),svec.end());




	return 0;
}


Unique algoritması  // Ardışık bir tane bile eleman olmayacak.
// Bir range i sıralayıp uniqe hale getirir isek her elemandan bir adet kalır.


unique();

int main(int argc, char const *argv[])
{
	randomize();
	list<int> 


	mylist.erase(unique(mylist.begin(), mylist.end()),mylist.end());
	return 0;
}


int main(int argc, char const *argv[])
{
	string str;
	cout << "Bir yazı girin";

	getLine(cin, str);
	str.erase(unique(str.begin(), str.end()),str.end());

	display(str);
	return 0;
}


int main(int argc, char const *argv[])
{
	vector<string> svec;
	randomize();

	fc(svec,100,rs);


	///Ardışık iki öğenin uzunluğu aynı olmayacak.
	svec.erase(unique(svec.begin(), svec.end() , [](const string &r1, const string &r2){return r1.size() == r2.size();}),svec.end());
	return 0;
}


****************************************************************************************************************

Transform Algoritması:
2 adet overload u mevcut 1 range den öğeyi alıyo fonksiyona gönderiyo geri dönüş değerini başka bir range  e yazıyo.

int main(int argc, char const *argv[])
{
	list<size_t> lenlist;
	fc(svec, 100)

	char c;
	cout << " bir karakter girin : ";
	cin >> c;


	return 0;
}


****************************************************************************************************************



lambda

int main(int argc, char const *argv[])
{
	auto f = [](double d1, double d2) -> int{return d1 + d2 }; /// Donus olarak int verdi.

	f(1.3 , 5.6);
	return 0;
}

Container lar


****************************************************************************************************************
Sequential Containers


vector
string
deque
list
forward_list --> C++ 11
array --> C++ 11


Associative Containers

Set
multiset
map
multimap
unordered_set
unordered_multiset
unordered_map
unordered_multimap

Container adaptörleri

stack
queue


Container kullanıcaksan vector kullan ? Senaryoların %80 inde vector işimizi görür
Ekleme ve silme işlemleri baştan veya sondan yapılıyorsa deque daha mantıklı sabit zamanda işlem yapar


Container ın referans semantiği ile kullanılmasını istiyor isek , SmartPointer kullanmak zorundayız.

vector<list<string>>  // 2011 ile kullanımı garanti altına alındı farklı bir derleyici sıkıntı çıkartabilir.

Vector Sınıfı
STL'in' en fazla kullanılan sınıfıdır. 
herşeyi sıra ile bir arada tutar


Konum bilgisi ile sabit zamanda erişmek. En önemli konu bu.
Sondan ekleme maaliyetini düşürmek için öğe sayısının ihtiyaç duyduğu bellek alanından daha uzun tutuyor.
En önemli problemi pointer yada iterator invalidation.
Bağlı listenin interface i diğerlerinden daha farklı


vector::::

int main(int argc, char const *argv[])
 {
 	std::vector<int> ivec;
 	cout << "ivec.size()" << ivec.size() << endl;

 	if(ivec.empty())
 		cout << "vector bos.."<< endl;


 	return 0;
 } 



Atama operator fonksyinu ve copy constructor member template değil
İki container i birbirine atama yapma şansım yok. Yada copy constructor kullanılarak kopyalama yapılamaz.

std::vector<int> ivec(20);


std::vector<double>  dvec(ivec.begin() , ivec.end());

bu şekilde atama yapabiliriz.

std::vector<int> v(15); --> sayısal değer ise 0 la başlar.
sınıf nesneleri için default constructor kullanılacak.

Bu kadar adet bu değerle başlat constructor ı -> 

Date mydate{12,7,1987};
vector<Date> myvec(20,mydate); ///20 tane myvecden oluştur.

display(myvec);



****************************************************************************************************************

std::vector<int> myvec;



kapasite fonksiyonu kapasite değerini get eder.
vector ün ilgili açılımının size_type türü
kapasitenin geri dönüş türü ne ise 


std::vector<int> myvec(35);

for (int i = 0; i < 20; ++i)
{
	myvec.push_back(k);

	cout << "capacity" << myvec.capacity() << endl;

}




std::vector<int> v;
auto cap = v.capacity();

while(true){
	x.push_back(0);
	if(x.capacity() != cap){
		cout << "new capacity" << x.capacity() << end;
		cap = x.capacity();
		getchar();

	}

}


reserve fonksiyonu kapasiteyi önceden ayarlar.n nesnelik yer önceden garanti altına alınır.

v.reserve(50000);
yavaş yavaş arttırmak istediğimizde kullanılabilir.


non-binding shrink request : 	kapasitenin altına düşürmeye çalışma sonucu oluşan durum
								vector de size düşürülmeye çalışılsa bile kapasite dşürülemez.

swap trick 

std::vector<int> (x).swap(x); //Kapasite düşer.

shrink_to_fit fonksiyonu

swap trick neredeyse bütün implementasyonlarda aynı.
size ve capacity yi eşitler.
resize() isimli fonksiyon container in size ini değiştir.. 

resize() ile silme yapabilirmiyim ? Evet.

Öğelere erişim
Range in başlangıç ve bitiş iteratörlerini kullanarak dönebilir.

vector string deque ve array container ları ekleme çıkarmayı overload etmişlerdir.
Contiainer ı vector yerine list yaparasnız. 

okuma araçlı erişimlerde const operatör kullanmalıyız
container daki elemanıdeğiştirceksek referans kullanmalıyız.

iterator yoluyla dolaşmanın amacı dolaşım döngüsü bozulmaz

vector<int> myvec(begin(a) , end(a));  ///C++11


****************************************************************************************************************



Uzunluğu odd olanlar silinecek even olanlar duplicate edilecek.

Tek bir iterator döngüsü ile yapılacak.

algoritma ve lamda kullanılmıcak
insert ve erase işlevlerini kullanarak

myvec.insert()  /// Nereye neyi insert ediceksiniz?


myvec.insert();




****************************************************************************************************************




struct Pred{
	bool operator<()(const string &r, const string &r2){
		///Lambda expression
	}
};

int main(int argc, char const *argv[])
{
	set<string , greater<string>> myset;  // Seti büyükten küçüğe sıralama


	randomize();
	fc(myset , 100 , rs);
	for (const auto &r : myset)
	{
		cout << r << endl;
	}
	return 0;
}



auto lambda = [](const string &r1 , const string &r2){
	if(r1.size() != r2.size())
		return r1.size() < r2.size();

	return r1 < r2;

}


set<string , decltype(lambda)> myset(lambda);



int main(int argc, char const *argv[])
{
	set<int> myset; ///fill constructor mevcut değil.
	vector<string> myvec;

	randomize();
	fc(myvec, 100 , rs);
	display(myvec);


	/// range constructor

	set<string> myset(myvec.begin(), myvec.end());
	display(myvec);

	cout << myset.size() << endl;
	/// multiset olsa idi aynı anahtardan birden fazla olabilecek idi.


	set<string> vipNames; 
	//set te tekilleştirme işlemi gerçekleşir.




	return 0;
}


///Setin ne işe yaradığı vurgusunu arttıralım 
int main(int argc, char const *argv[])
{
	
	set<Date> impDates;
	randomize();
	for(int k = 0 ; k < 200 ; k++ )
	impDates.insert();



////// Asıl tarihlerimiz burda: 

	std::vector<Date> DateVec;
	fc(datevvec , 2000 , Date::Random);
	
	for(auto &d : datevec )
	{
		if(impDates.find(d) != impDates.end()){
			cout << "Özel Tarih" << d << endl;	
		}
		d++;
	}



	return 0;

}

****************************************************************************************************************

set için ; 


Burada push back veya push front mevcut değil. Insert kullanıcaz.Insert edilmesi gereken yere insert edecek.
Insert ün interface i : 
Geri dönüş değeri pair in iteratör bool açılımı. Second ı ekleme yapılmışsa true olacak.

int main(int argc, char const *argv[])
{
	set<string> myset;
	randomize();
	fc(myset , 20 , rs);
	display(myset);
	string name;

	cout << "eklenecek ismi girin." << endl;

	auto mp = myset.insert(name);
	if(mp.second){
		cout << "ekleme yapildi" << endl;
		display(myset);
		cout << "eklenen öğe : " << *mp.First << endl;
	}
	else{
		cout << "Zaten var." endl;
		//// mp.first->assign(10 , 'A');

	}

	return 0;
}



value_type&& val semantiği taşıma semantiğine denk geliyor.
mapdeki , multimap deki , multisetteki , Setteki anahtar const kabul edilir değiştirilemez.
Silip tekrar ekleme yapmak gerekir.
erase() -> iteratorler silen fonksiyon


unordered set ile hızı arttırabiliyoruz. Hash tablosu olduğu için ince ayar yapılabilen bir interface i mevcut
birden fazla insert işlemi tek insert işleminden daha verimli.n taneyi tek seferde insert edebilecek bir interface varsa performansı arttırır , düşürmez


int main(int argc, char const *argv[])
{
	list<string> mylist ;
	fc(mylist , 10 , rs);
	display(mylist);

	myset.insert(mylist.begin() , mylist.end() );

	myset.insert({"erkan" , "gurkan" , "turkan" , "serkan" , "tarkan"});






	return 0;
}


****************************************************************************************************************


find fonksiyonu eleman varsa iterator yoksa end i döndürücek.
Multiset ise bulunan arananlardan ilki.
Set is unique olduğu için count() fonksiyonu 1  ya da 0 döndürmektedir.

Lower bound ve upper bound değerler nedir ? 

Sıralı veri yapılarına yönelik bir kavram. Container da tutulan veriler için geçerli , insert edilecek değer için kulalnılır. 

Lower Bound : >= insert edilebeileceği ilk konum yani ondan büyük eşit olan ilkinin konumu sırayı bozmadan insert edebileceğim ilk konum
Upper Bound : >  elemanın eklenebileceği son yer.

5 6 7 için 6 sayısını ele alırsak 
lower bound ı -> 6
upper bound ı -> 7

lower bound ve upper bound range olursa arada nesnler varsa bu aradaki range e equal bound denir.



int main(int argc, char const *argv[])
{
	multiset<int> myset;
	randomize();

	fc(myset, 100 , [](){return rand() % 10; });

	display(myset);
	int ival;
	cout << "degeri girin";
	cin >> ival;

	for (auto iterp = myset.equal_range(ival) ; iterp)
	return 0;
}
****************************************************************************************************************


auto n = myset.erase(ival);

cout << "n öğe silindi" <<  endl;

auto iter = myself.find(ival); --> iter i geri döndürür.

Map herzaman pair tutuyor.

int main(int argc, char const *argv[])
{
	multiset<int, greater<int>> myset;
	randomize();

	auto x = myset.key_comp();

	cout << boolalpha << x(10,30) << endl;

	return 0;
}



boolalpha manipülatörü -> akımı true false veya 0 - 1 mi kullanıdırtsın.

****************************************************************************************************************

Map Container 

Her değere karşılık bir key var.

int main(int argc, char const *argv[])
{
	map<string, int> mymap;
	map<string , string> mymap;
	map<string , Date , greater <string> > bDateMap;

	map<string, int> myset;

	map<string , int > mymap {{"zeliha" , 76} , {"ali" , 27} , {"nur" , 27} , {"deniz" , 22} , {"ayca" , 22}} ; 

	for (auto iter  = mymap.begin(); iter != mymap.end() ; ++iter )
		cout << iter->first << " " <<iter->second; // Anahtara
	mymap.insert(pair<string, int>("orhan" , 27);
		mymap.insert(make_pair("nurdan" , 45 ));
		mymap.insert(map<string , int , ,greater >)

	return 0;
}


for (int k = 0 ; k < 1000 ; ++k)
	nd_map.insert(make_pair)











****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************



















****************************************************************************************************************
















	