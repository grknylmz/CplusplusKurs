////////////////////////////////// C++ Kurs //////////////////////////////////////////
////////////////////////////////// 16.05.2015 ////////////////////////////////////////
Neden C++?
	Verim Kritik
	Multi Paradigm Programlama Tekniği
	Çok fazla kütüphane varlığı -- Qt
	
Farklılıklar
implicit int yok mecburen tür belirtilmek zorunda
C de legal C++ error

int main yaz 



void fonksiyonun geri dönüş değeri olabilir ama ifade void olmak zorunda.
Yani fonksiyonun içerisinde void bi fonksiyonu geri döndürebiliriz.

Veri kaybı otomatik tür dönüşümünde syntax hatası değil.

İlk değer verme
C den farklı olarak T x {exp } c++ 11 le gelen özellik.


int func(){
	double dval = 3.4;   /// İkisindede geçerli
	int ival = dval ;   /// ikisindede geçerli 
	
	
	int ival {dval}; /// Bu syntax de tür dönüşümü syntax hatası değer kaybı engellenebilir.  Narrowing conversion  ilk değer verme syntaxi
		
}
int ival = dval ;

int main(){
	func();
	
	return 0;
}
Aritmetik türden değişkenler çok özel bir durum yoksa tanımlanmalı.

int temp(45);
int temp{45};
int temp = {45};

bunların hepsi C++ da geçerlidir.
Döngü değişkennini döngünün içinde bildirmeye çalış.

Workaround makrosu

Türlere yönelik farklılıklar : 

Bool Mevcut
C++ da bool ve yine C deki gibi int değeri kullanılabilir.







#include <iostream>


using namespace std;

int main(){
	
	cout << typeid(10 > 5).name() << endl;
	cout << sizeof(bool) << endl;
	
}

extern anahtar sözcüğü ile const bir nesneye ilk değer verirseniz dış bağlantı yapılabilir.
const int *ptr = &x; ----> const olan *ptr
int * const ptr = &x; ----> const olan ptr;


#include <iostream>

using namespace std;

int main(){
	cout << "Hello World" << endl;
	
	return 0;

	
}







package dediğimiz kavram c++ da namespace olarak geçiyor.
bir isim alanındaki isimi erişmek için;

neco::X --> ismi neco olan package da ara
:: -> çözünürlük operatörü



#include <iostream>

using namespace std;

int main(){
	int x = 10;
	double dval = 2.3;
	
	
	cout << x << << "    " << dval << "\n";
		
	
	return 0;
}

#include <iostream>

using namespace std;

int main(){
		
	
	return 0;
}

int main(){
	int x,y;
	
	cout << "iki sayi girniniz" ;
	cin >> x >> y;
	
	
	return 0;
}



.a

->b

::x

class Myclass{

public:

private:

protected:


};


struct da heryer public 
class içerisinde değişken.

Sınıfın elemanları:
Data Members		/// Tipik olarak private olarak konulur, protected kalıtım ile devreye girecek
-Static 
-Non Static
Member Functions 
m.func()  // Nesne ile çağırma
ptr->func() // Fonksyion ile çağırma

Sınıfların üye fonksiyonu tekrar bildirilemez

int Myclass::func(){

	myclass::x -----> sadece class scope da arama
	this.x; -----> """"
};




class Myclass{
public:
	void func();
	void foo()const; /// içinde sınıfında veri elemanlarını değiştirmeye çalışmak syntax hatası Getter ?
	////Const elemanlar ile sınıfın sadece const fonksiyonlarını çağırabiliriz.




};



class Myclass{

public:
	****** func(int);
	****** func(int)const; /////Const overloading

	x kendisini const sa const fonksiyon çağırılır değilse normal fonksiyon çağırılır.


};




#include <iostream>
#include <string>
using namespace std;

class Account{
public:

    string getAccountName();
    void transfer(Account &r, double sum);
};

int main(){
    Account necati;
    Account sina;

    necati.transfer(sina,1000);

    return 0;
}



#include <iostream>
#include <string>
using namespace std;

class Account{
    string name;
    double sum;
    mutable int callCounter; ///mutable kullanılarak const fonksiyonuyla çağrılabilir hale getirtilir.

public:
    void display()const;
    
};



void Account::display() const {
    callCounter++;////Sınıfın veri elemanı değiştirilemez
    

}




int main(){
   

    return 0;
}



Sınıfın veri elemanının const üye fonksyionlar değiştirilmesini istiyor isek , mutable anahtar sözcüğü ile tanımlamak zorundayız.
Değişmeyecek bütün veri elemanları için const anahtar sözcüğü kullanılmak zorundadır.

Constructor : :

#include <string>
#include <iostream>



using namespace std;

class Myclass{
	Myclass(); /// Gecerli ctor private olabilir.
public:
	Myclass();
	Myclass(int = 0);
	Myclass(int = 0, int = 0);

};



////CPP


Myclass::Myclass(){
cout << "Myclass::Myclass()" << endl;

}

int main(){

cout << "main baslıyor"<< endl;
cout << "Main bitiyor" << endl;


Myclass *ptr; /////Bu bir pointer, nesne değil o yüzden constructor çağrılmayacak.
Myclass m;
Myclass &r = m; //// Referans constructor ı çağırtmaz aksine isim verilir sadece.

Myclass m(); /// İsmi m olan gdd Myclass turu olan bir işlevin bildirimi.
Myclass m{}; ///C++ 11 le gelen nesne semantiği

cout << "main basladı" << endl;
Myclass x;

}

14.06.2015 Pazar


Constructor sınıfın public non-static inline fonksiyonudur.

Destructor ın ismiyle çaprıldığı tek yer 
// placement new operatörü //
Destructor tanımlamazsak derleyici sınıfa public non static inline kod ekler.

R.A.I.I.

Resource Acquisiton is Initialization
Smart pointer Sınıfları
Dinamik nesne bellekte yer tutmaya devam eder eğer delete edilmezse.


INLINE FONKSİYONLAR
extern c diye belirtiyorduk c'den ' aldığımız kaynak kodlarda.
1- Çok sık çağrılan kodu küçük , ona yönelik çözümlerden biri (C'deki' function like macroya alternatif);

inline int square(int a){

	return a*a;
}


bu inline fonksyionlar başlık dosyalarının içindedirler.
Sınıfın non static üye fonksiyonları , sınıfın static üye fonksyionları , 

friend int func(){
	
}

///////////////////


#include <iostream>

using namespace std;



class Point{

};

int main(){


}


Sınıflara ayırma amacı :
1- Soyutlama yapabilme
2- Kolay değişiklik yapabilme

M.I.L. Member Initialization List
ctor syntaxi 

Bazen sınıfın veri elemanlarına referans vermek zorundayız buna göre bunları MIL syntax ina uygun yapmak zorundayız




Point::Point(double x, double y) : mx(x) , my(y) {        
}


///// Const veya referans elemanlar kullanıyor isek MIL syntax ini kullanmak zorundayız.
///// C++ 11 e kadar ilk değer vermenin tek yolu buydu.


C++ 11 le gelen iki tane çok önemli anahtar sözcük : 
default
delete

/// Operator overloading

Point() = default; ///C++ 11
friend std::ostream &operator<<(std::ostream &os, const Point &r){
	return os << r.mx << r.my << endl;

} 			



Sınıf elemanlarına default arguman  atama

class Data{
	int mx = 0;
	int my;
	int mz;
public:
	Data() : my{13} , mz{56}{}
	void display()const{
		cout << mx << my << mz << endl;
	}

};


int int main(int argc, char const *argv[])
{
	Data myData;
	myData.display();
	

	return 0;
}


Başlık dosyasında using bildirimi asla yazılmıcak
Başlık include eder 

Başlıkta örneğin std::string m_name;  tarzında kullanılacak.üü

static std::list<Fighter *> ms_list;
Tanımlamada static anahtar sözcüğü yer almaz. Başlık dosyasında static anahtar sözcüğü kullanılmaz.
Nesneler main çağrılmasından önce construct edilecek.

Named Constructor - İsimlendirilmiş Yapılandırıcı
Kendisi constructor değil ama bir üye sınıfın constructor ı olarak davranıyor.
Öyle durumlar varki client a otomatik veya statik ömürlü oluşturtmak istemiyoruz.
Sınıfa statik bir üye fonksyionu yazarız , private bölüme erişebilir. New olarak erişir.

C++ da new operatorleri nesnenin adresini verir.


//
// Created by Gurkan Yilmaz on 27/06/15.
//

#include <iostream>
#include "Dyna.h"


using namespace std;

class Dyna{
    int mx;
    Dyna(int x): mx{x}{}



public:
    static Dyna *createObject(int val){
        return new Dyna(val);
    }

    void display()const{

    }

};



int main(){
    Dyna *p = Dyna::createObject(45);

    p->display();
    
}


////////////////////////////////////////////////////////


#include <iostream>
#include "Point.h"


using namespace std;


class Complex{
    Complex(double r, double i); /// kartezyen
    Complex(double angle, double distance , int kutupsal); // kutupsal

public:

    static Complex *createCarte(double r, double i){
        return new Complex(r,i);
    }
    
    
    static Complex *createPolar(double angle, double distance , int kutupsal){
        return new Complex(angle , distance , kutupsal);
    }
};






int main(){


    return 0;
}

Singleton ::



Bir sınıf türünden sadece bir nesne olacak ikinci bir nesne oluşturulmasına izin verilmeyecek.
Global access verilecek tüm clientlar bunu kullanabilecek.
Modellediği nesnenin olayı bu. 
İkinci nesne oluşturulamaz. Nesne sayısının artması compile time da tespit edilip hatta öncesinde syntax hatası olarak verilerek beliritilir.


Meyer Singleton Kodu::


class Sina{
	Sina(){}

public:
	static Sina *singleton(){
		static Sina single;
		return &single;
	}
};


int main(){

	auto ptr = Sina::singleton();
	ptr->display();
}

/////////////////////////////


const ve static ise ilk değer verilebilir sınıf içerisinde


class Data{
	static const size_t size = 100;
	static int a[];

public:
	static size_t getsize(){ return ms_size; }  ///static üye fonksiyon const olmaz!!!!!!!!
};

int Data::a[Data::ms_size];



int int main(int argc, char const *argv[])
{
	cout<< Data::getsize()<< endl;
	return 0;
}


//////////////////////////////////////////////////////////////


class Account{
	double m_interest_rate;
	const double m_interest_rate;
	static double m_interest_rate;
	const static double m_interest_rate;
	
public:




};



























//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////


















































	