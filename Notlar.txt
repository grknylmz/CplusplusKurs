////////////////////////////////// C++ Kurs //////////////////////////////////////////
////////////////////////////////// 16.05.2015 ////////////////////////////////////////
Neden C++?
	Verim Kritik
	Multi Paradigm Programlama Tekniği
	Çok fazla kütüphane varlığı -- Qt
	
Farklılıklar
implicit int yok mecburen tür belirtilmek zorunda
C de legal C++ error

int main yaz 



void fonksiyonun geri dönüş değeri olabilir ama ifade void olmak zorunda.
Yani fonksiyonun içerisinde void bi fonksiyonu geri döndürebiliriz.

Veri kaybı otomatik tür dönüşümünde syntax hatası değil.

İlk değer verme
C den farklı olarak T x {exp } c++ 11 le gelen özellik.


int func(){
	double dval = 3.4;   /// İkisindede geçerli
	int ival = dval ;   /// ikisindede geçerli 
	
	
	int ival {dval}; /// Bu syntax de tür dönüşümü syntax hatası değer kaybı engellenebilir.  Narrowing conversion  ilk değer verme syntaxi
		
}

int main(){
	func();
	
	return 0;
}
Aritmetik türden değişkenler çok özel bir durum yoksa tanımlanmalı.

int temp(45);
int temp{45};
int temp = {45};

bunların hepsi C++ da geçerlidir.
Döngü değişkennini döngünün içinde bildirmeye çalış.

Workaround makrosu

Türlere yönelik farklılıklar : 

Bool Mevcut
C++ da bool ve yine C deki gibi int değeri kullanılabilir.







#include <iostream>


using namespace std;

int main(){
	
	cout << typeid(10 > 5).name() << endl;
	cout << sizeof(bool) << endl;
	
}

extern anahtar sözcüğü ile const bir nesneye ilk değer verirseniz dış bağlantı yapılabilir.
const int *ptr = &x; ----> const olan *ptr
int * const ptr = &x; ----> const olan ptr;


#include <iostream>

using namespace std;

int main(){
	cout << "Hello World" << endl;
	
	return 0;

	
}







package dediğimiz kavram c++ da namespace olarak geçiyor.
bir isim alanındaki isimi erişmek için;

neco::X --> ismi neco olan package da ara
:: -> çözünürlük operatörü



#include <iostream>

using namespace std;

int main(){
	int x = 10;
	double dval = 2.3;
	
	
	cout << x << << "    " << dval << "\n";
		
	
	return 0;
}

#include <iostream>

using namespace std;

int main(){
		
	
	return 0;
}

int main(){
	int x,y;
	
	cout << "iki sayi girniniz" ;
	cin >> x >> y;
	
	
	return 0;
}



.a

->b

::x

class Myclass{

public:

private:

protected:


};


struct da heryer public 
class içerisinde değişken.

Sınıfın elemanları:
Data Members		/// Tipik olarak private olarak konulur, protected kalıtım ile devreye girecek
-Static 
-Non Static
Member Functions 
m.func()  // Nesne ile çağırma
ptr->func() // Fonksyion ile çağırma

Sınıfların üye fonksiyonu tekrar bildirilemez

int Myclass::func(){

	myclass::x -----> sadece class scope da arama
	this.x; -----> """"
};




class Myclass{
public:
	void func();
	void foo()const; /// içinde sınıfında veri elemanlarını değiştirmeye çalışmak syntax hatası Getter ?
	////Const elemanlar ile sınıfın sadece const fonksiyonlarını çağırabiliriz.




};



class Myclass{

public:
	****** func(int);
	****** func(int)const; /////Const overloading

	x kendisini const sa const fonksiyon çağırılır değilse normal fonksiyon çağırılır.


};




#include <iostream>
#include <string>
using namespace std;

class Account{
public:

    string getAccountName();
    void transfer(Account &r, double sum);
};

int main(){
    Account necati;
    Account sina;

    necati.transfer(sina,1000);

    return 0;
}



#include <iostream>
#include <string>
using namespace std;

class Account{
    string name;
    double sum;
    mutable int callCounter; ///mutable kullanılarak const fonksiyonuyla çağrılabilir hale getirtilir.

public:
    void display()const;
    
};



void Account::display() const {
    callCounter++;////Sınıfın veri elemanı değiştirilemez
    

}




int main(){
   

    return 0;
}



Sınıfın veri elemanının const üye fonksyionlar değiştirilmesini istiyor isek , mutable anahtar sözcüğü ile tanımlamak zorundayız.
Değişmeyecek bütün veri elemanları için const anahtar sözcüğü kullanılmak zorundadır.

Constructor : :

#include <string>
#include <iostream>



using namespace std;

class Myclass{
	Myclass(); /// Gecerli ctor private olabilir.
public:
	Myclass();
	Myclass(int = 0);
	Myclass(int = 0, int = 0);

};



////CPP


Myclass::Myclass(){
cout << "Myclass::Myclass()" << endl;

}

int main(){

cout << "main baslıyor"<< endl;
cout << "Main bitiyor" << endl;


Myclass *ptr; /////Bu bir pointer, nesne değil o yüzden constructor çağrılmayacak.
Myclass m;
Myclass &r = m; //// Referans constructor ı çağırtmaz aksine isim verilir sadece.

Myclass m(); /// İsmi m olan gdd Myclass turu olan bir işlevin bildirimi.
Myclass m{}; ///C++ 11 le gelen nesne semantiği

cout << "main basladı" << endl;
Myclass x;

}

14.06.2015 Pazar


Constructor sınıfın public non-static inline fonksiyonudur.

Destructor ın ismiyle çaprıldığı tek yer 
// placement new operatörü //
Destructor tanımlamazsak derleyici sınıfa public non static inline kod ekler.

R.A.I.I.

Resource Acquisiton is Initialization
Smart pointer Sınıfları
Dinamik nesne bellekte yer tutmaya devam eder eğer delete edilmezse.


INLINE FONKSİYONLAR
extern c diye belirtiyorduk c'den ' aldığımız kaynak kodlarda.
1- Çok sık çağrılan kodu küçük , ona yönelik çözümlerden biri (C'deki' function like macroya alternatif);

inline int square(int a){

	return a*a;
}


bu inline fonksyionlar başlık dosyalarının içindedirler.
Sınıfın non static üye fonksiyonları , sınıfın static üye fonksyionları , 

friend int func(){
	
}

///////////////////


#include <iostream>

using namespace std;



class Point{

};

int main(){


}


Sınıflara ayırma amacı :
1- Soyutlama yapabilme
2- Kolay değişiklik yapabilme

M.I.L. Member Initialization List
ctor syntaxi 

Bazen sınıfın veri elemanlarına referans vermek zorundayız buna göre bunları MIL syntax ina uygun yapmak zorundayız




Point::Point(double x, double y) : mx(x) , my(y) {        
}


///// Const veya referans elemanlar kullanıyor isek MIL syntax ini kullanmak zorundayız.
///// C++ 11 e kadar ilk değer vermenin tek yolu buydu.


C++ 11 le gelen iki tane çok önemli anahtar sözcük : 
default
delete

/// Operator overloading

Point() = default; ///C++ 11
friend std::ostream &operator<<(std::ostream &os, const Point &r){
	return os << r.mx << r.my << endl;

} 			



Sınıf elemanlarına default arguman  atama

class Data{
	int mx = 0;
	int my;
	int mz;
public:
	Data() : my{13} , mz{56}{}
	void display()const{
		cout << mx << my << mz << endl;
	}

};


int int main(int argc, char const *argv[])
{
	Data myData;
	myData.display();
	

	return 0;
}



























	