////////////////////////////////// C++ Kurs //////////////////////////////////////////
////////////////////////////////// 16.05.2015 ////////////////////////////////////////
Neden C++?
	Verim Kritik
	Multi Paradigm Programlama Tekniği
	Çok fazla kütüphane varlığı -- Qt
	
Farklılıklar
implicit int yok mecburen tür belirtilmek zorunda
C de legal C++ error

int main yaz 



void fonksiyonun geri dönüş değeri olabilir ama ifade void olmak zorunda.
Yani fonksiyonun içerisinde void bi fonksiyonu geri döndürebiliriz.

Veri kaybı otomatik tür dönüşümünde syntax hatası değil.

İlk değer verme
C den farklı olarak T x {exp } c++ 11 le gelen özellik.


int func(){
	double dval = 3.4;   /// İkisindede geçerli
	int ival = dval ;   /// ikisindede geçerli 
	
	
	int ival {dval}; /// Bu syntax de tür dönüşümü syntax hatası değer kaybı engellenebilir.  Narrowing conversion  ilk değer verme syntaxi
		
}
int ival = dval ;

int main(){
	func();
	
	return 0;
}
Aritmetik türden değişkenler çok özel bir durum yoksa tanımlanmalı.

int temp(45);
int temp{45};
int temp = {45};

bunların hepsi C++ da geçerlidir.
Döngü değişkennini döngünün içinde bildirmeye çalış.

Workaround makrosu

Türlere yönelik farklılıklar : 

Bool Mevcut
C++ da bool ve yine C deki gibi int değeri kullanılabilir.







#include <iostream>


using namespace std;

int main(){
	
	cout << typeid(10 > 5).name() << endl;
	cout << sizeof(bool) << endl;
	
}

extern anahtar sözcüğü ile const bir nesneye ilk değer verirseniz dış bağlantı yapılabilir.
const int *ptr = &x; ----> const olan *ptr
int * const ptr = &x; ----> const olan ptr;


#include <iostream>

using namespace std;

int main(){
	cout << "Hello World" << endl;
	
	return 0;

	
}







package dediğimiz kavram c++ da namespace olarak geçiyor.
bir isim alanındaki isimi erişmek için;

neco::X --> ismi neco olan package da ara
:: -> çözünürlük operatörü



#include <iostream>

using namespace std;

int main(){
	int x = 10;
	double dval = 2.3;
	
	
	cout << x << << "    " << dval << "\n";
		
	
	return 0;
}

#include <iostream>

using namespace std;

int main(){
		
	
	return 0;
}

int main(){
	int x,y;
	
	cout << "iki sayi girniniz" ;
	cin >> x >> y;
	
	
	return 0;
}



.a

->b

::x

class Myclass{

public:

private:

protected:


};


struct da heryer public 
class içerisinde değişken.

Sınıfın elemanları:
Data Members		/// Tipik olarak private olarak konulur, protected kalıtım ile devreye girecek
-Static 
-Non Static
Member Functions 
m.func()  // Nesne ile çağırma
ptr->func() // Fonksyion ile çağırma

Sınıfların üye fonksiyonu tekrar bildirilemez

int Myclass::func(){

	myclass::x -----> sadece class scope da arama
	this.x; -----> """"
};




class Myclass{
public:
	void func();
	void foo()const; /// içinde sınıfında veri elemanlarını değiştirmeye çalışmak syntax hatası Getter ?
	////Const elemanlar ile sınıfın sadece const fonksiyonlarını çağırabiliriz.




};



class Myclass{

public:
	****** func(int);
	****** func(int)const; /////Const overloading

	x kendisini const sa const fonksiyon çağırılır değilse normal fonksiyon çağırılır.


};




#include <iostream>
#include <string>
using namespace std;

class Account{
public:

    string getAccountName();
    void transfer(Account &r, double sum);
};

int main(){
    Account necati;
    Account sina;

    necati.transfer(sina,1000);

    return 0;
}



#include <iostream>
#include <string>
using namespace std;

class Account{
    string name;
    double sum;
    mutable int callCounter; ///mutable kullanılarak const fonksiyonuyla çağrılabilir hale getirtilir.

public:
    void display()const;
    
};



void Account::display() const {
    callCounter++;////Sınıfın veri elemanı değiştirilemez
    

}




int main(){
   

    return 0;
}



Sınıfın veri elemanının const üye fonksyionlar değiştirilmesini istiyor isek , mutable anahtar sözcüğü ile tanımlamak zorundayız.
Değişmeyecek bütün veri elemanları için const anahtar sözcüğü kullanılmak zorundadır.

Constructor : :

#include <string>
#include <iostream>



using namespace std;

class Myclass{
	Myclass(); /// Gecerli ctor private olabilir.
public:
	Myclass();
	Myclass(int = 0);
	Myclass(int = 0, int = 0);

};



////CPP


Myclass::Myclass(){
cout << "Myclass::Myclass()" << endl;

}

int main(){

cout << "main baslıyor"<< endl;
cout << "Main bitiyor" << endl;


Myclass *ptr; /////Bu bir pointer, nesne değil o yüzden constructor çağrılmayacak.
Myclass m;
Myclass &r = m; //// Referans constructor ı çağırtmaz aksine isim verilir sadece.

Myclass m(); /// İsmi m olan gdd Myclass turu olan bir işlevin bildirimi.
Myclass m{}; ///C++ 11 le gelen nesne semantiği

cout << "main basladı" << endl;
Myclass x;

}

14.06.2015 Pazar


Constructor sınıfın public non-static inline fonksiyonudur.

Destructor ın ismiyle çaprıldığı tek yer 
// placement new operatörü //
Destructor tanımlamazsak derleyici sınıfa public non static inline kod ekler.

R.A.I.I.

Resource Acquisiton is Initialization
Smart pointer Sınıfları
Dinamik nesne bellekte yer tutmaya devam eder eğer delete edilmezse.


INLINE FONKSİYONLAR
extern c diye belirtiyorduk c'den ' aldığımız kaynak kodlarda.
1- Çok sık çağrılan kodu küçük , ona yönelik çözümlerden biri (C'deki' function like macroya alternatif);

inline int square(int a){

	return a*a;
}


bu inline fonksyionlar başlık dosyalarının içindedirler.
Sınıfın non static üye fonksiyonları , sınıfın static üye fonksyionları , 

friend int func(){
	
}

///////////////////


#include <iostream>

using namespace std;



class Point{

};

int main(){


}


Sınıflara ayırma amacı :
1- Soyutlama yapabilme
2- Kolay değişiklik yapabilme

M.I.L. Member Initialization List
ctor syntaxi 

Bazen sınıfın veri elemanlarına referans vermek zorundayız buna göre bunları MIL syntax ina uygun yapmak zorundayız




Point::Point(double x, double y) : mx(x) , my(y) {        
}


///// Const veya referans elemanlar kullanıyor isek MIL syntax ini kullanmak zorundayız.
///// C++ 11 e kadar ilk değer vermenin tek yolu buydu.


C++ 11 le gelen iki tane çok önemli anahtar sözcük : 
default
delete

/// Operator overloading

Point() = default; ///C++ 11
friend std::ostream &operator<<(std::ostream &os, const Point &r){
	return os << r.mx << r.my << endl;

} 			



Sınıf elemanlarına default arguman  atama

class Data{
	int mx = 0;
	int my;
	int mz;
public:
	Data() : my{13} , mz{56}{}
	void display()const{
		cout << mx << my << mz << endl;
	}

};


int int main(int argc, char const *argv[])
{
	Data myData;
	myData.display();
	

	return 0;
}


Başlık dosyasında using bildirimi asla yazılmıcak
Başlık include eder 

Başlıkta örneğin std::string m_name;  tarzında kullanılacak.üü

static std::list<Fighter *> ms_list;
Tanımlamada static anahtar sözcüğü yer almaz. Başlık dosyasında static anahtar sözcüğü kullanılmaz.
Nesneler main çağrılmasından önce construct edilecek.

Named Constructor - İsimlendirilmiş Yapılandırıcı
Kendisi constructor değil ama bir üye sınıfın constructor ı olarak davranıyor.
Öyle durumlar varki client a otomatik veya statik ömürlü oluşturtmak istemiyoruz.
Sınıfa statik bir üye fonksyionu yazarız , private bölüme erişebilir. New olarak erişir.

C++ da new operatorleri nesnenin adresini verir.


//
// Created by Gurkan Yilmaz on 27/06/15.
//

#include <iostream>
#include "Dyna.h"


using namespace std;

class Dyna{
    int mx;
    Dyna(int x): mx{x}{}



public:
    static Dyna *createObject(int val){
        return new Dyna(val);
    }

    void display()const{

    }

};



int main(){
    Dyna *p = Dyna::createObject(45);

    p->display();
    
}


////////////////////////////////////////////////////////


#include <iostream>
#include "Point.h"


using namespace std;


class Complex{
    Complex(double r, double i); /// kartezyen
    Complex(double angle, double distance , int kutupsal); // kutupsal

public:

    static Complex *createCarte(double r, double i){
        return new Complex(r,i);
    }
    
    
    static Complex *createPolar(double angle, double distance , int kutupsal){
        return new Complex(angle , distance , kutupsal);
    }
};






int main(){


    return 0;
}

Singleton ::



Bir sınıf türünden sadece bir nesne olacak ikinci bir nesne oluşturulmasına izin verilmeyecek.
Global access verilecek tüm clientlar bunu kullanabilecek.
Modellediği nesnenin olayı bu. 
İkinci nesne oluşturulamaz. Nesne sayısının artması compile time da tespit edilip hatta öncesinde syntax hatası olarak verilerek beliritilir.


Meyer Singleton Kodu::


class Sina{
	Sina(){}

public:
	static Sina *singleton(){
		static Sina single;
		return &single;
	}
};


int main(){

	auto ptr = Sina::singleton();
	ptr->display();
}

/////////////////////////////


const ve static ise ilk değer verilebilir sınıf içerisinde


class Data{
	static const size_t size = 100;
	static int a[];

public:
	static size_t getsize(){ return ms_size; }  ///static üye fonksiyon const olmaz!!!!!!!!
};

int Data::a[Data::ms_size];



int int main(int argc, char const *argv[])
{
	cout<< Data::getsize()<< endl;
	return 0;
}


//////////////////////////////////////////////////////////////


class Account{
	double m_interest_rate;
	const double m_interest_rate;
	static double m_interest_rate;
	const static double m_interest_rate;


	const static de integral type olmak zorunda !!!!! double float vs olamaz.

public:

};




////////////////////////////////////////////////////////////////

Conversion Constructor:


class Myclass{
	Myclass(int);
public:

	Myclass(int){
		cout<< "Myclass(int)"
	}

};


void func(Myclass m){


}





int int main(int argc, char const *argv[])
{
	Myclass m(456);
	func(78);
	m = 20;




	return 0;
}
//////////////////////////////////////////////////////////////
#include <string>
#include <iostream>

using namespace std;




class Counter{
	Counter();
public:
	Counter();
	Counter(int);

};


void func(const Counter &r);





int main(){
	string s;
	s = "mustafa";
	Counter mycounter;

	//////Counter c(15);
	//////func(c);


	func(15);


	return 0;

}

//////////////////////////////////////////////////////////////


int int main(int argc, char const *argv[])
{
	int ci;
	Counter c;


	func(c);
	return 0;
}



Explicit anahtar sözcüğü:
explicit yazarak dönüşümleri gösterek yapmasını isteriz.
Diğer şekilde implicit yapar ve göstermez cast'i';

Exaxct match
promotion

user defined conversions

Bir standard conversion sonrasında user defined conversion gerekiyorsa derleyici bunu yapar.
Tam tersi yine mümkün.
 

//////////////////////////////////////////////////////////////

using namespace std;



int int main(int argc, char const *argv[])
{
	T a[100]; /// default init.
	T x; ////Default initialization
	T x(10);	T x{10};	/// Value init
	T x = 100 /// Copy init copy constructor çağrılır.

	T x(19);
	T y = 19;  /// explicit olması durumunda error olur.


	string s1("Ali");
	string s2 = "murtaza"; //// Explicit olsa idi syntax hatası

	return 0;
}



En önemli Özellikler C++11 le gelen

1- Move semantiği
2- 
3-
4-
5-


//////////////////////////////////////////////////////////////




class Myclass{

public:
	Myclass(){

		cout << "Myclass :: counstructor" << endl;

	}

	~Myclass(){
		cout << "Myclass :: destructor" << endl;
	}

	void display()const{
		cout << "Myclass::display"<< endl;
	}
};

#include <memory>
using namespace std;

int int main(int argc, char const *argv[])
{
	unique_ptr /// Pointer ın scope u bittiğinde nesne destruct olacak

	Myclass *p = new Myclass();

	p->display();
	delete(p);
	

	///////////




	return 0;
}

void func(unique_ptr<Myclass>); //// Sınıf türünden ise copy init





int int main(int argc, char const *argv[])
{
	cout << "main basladi" << endl;
	{
		unique_ptr<Myclass> ptr(new Myclass);
		ptr->display();
	}

	cout << "Main bitiyor" << endl;

	return 0;
}


//////////////////////////////////////////////////////////////

class Counter{

public:
	explicit operator int()const;

};

Primitive türlerde copy init diye birşey yok.

Operator overloading
// STL'in' temel dayanağı //

T (expr);


static-cast
const-cast
reinterpret-cast
dynamic-cast

//////////////////////////////////////////////////////////////

int main(){
	static_cast<double>(ival) ///Operandı parantez içinde yazmak zorundayız. Syntax zorunluluğu
	const_cast<double>
	reinterpret_cast<double>
	dynamic_cast<double> 	///C'de karşılığı mevcut değil , kalıtımla çalışırken runtime  polymorfizm le alakalı.



}

#include <cstdlib>
#include <ctime>


int int main(int argc, char const *argv[])
{
	dval = static_cast<double>(x)/y;
	return 0;
}





int int main(int argc, char const *argv[])
{
	int x = 10;
	int y = 20;
	double dval;


	dval =static_cast<double> (x)/y; 

	srand((unsigned int)time(nullptr));

	srand(static_cast<unsigned int>(time (nullptr)));




	const_cast<>
	return 0;
}



char *mystrchr(const char *ptr, int ch){
	while(*ptr != '0'){
		if(*ptr == ch)
			return (char * ptr) //// C hali C++ için return (const_cast<char * > ptr)
	}
}


reinterpret_cast ===

int int main(int argc, char const *argv[])
{
	double dval = 2.3;
	char *ptr;



	ptr = char(*)&dval;

	ptr = reinterpret_cast<char*>(&dval);   //// a türünden bir nesnenin adresini b türünden bir nesnenin adresine cast ediyorum. Yani adres sadece
	///// cast edilir.
	return 0;
}



İki ayrı dönüşümün yapılması::::

ptr = reinterpret_cast<char *>(const_cast<double *>(&dval));

Operator overloading ::

Etrafta bir nesne yoksa operator overloading aracının kullanılmasına gerek yok.
Her operator yüklenemez.
nokta operatoru
::
sizeof
? : Koşul operatörü
.*
typeid
overload edilemeyen operatorler


Operator Overload Edilmesi


class Data{
public:

	x.operator>(y);   //// x>y;
	operator>(const Data &r)const;


	!myData
	operator!(const Data &r);
	operator!()const;


	arity  ==== operatorun Unari mi binary mi olması durumuna arity deniliyor.

};


Birden fazla anlama gelen operatorler::

*
&
+
-

static üye operator fonksiyonu olamaz.!!
tum operator fonksyionları ismiyle çağrılabilir.

cout << x 




//////////////////////////////////////////////////////////////



#include <string>
using namespace std::


int main(int argc, char const *argv[])
{
	int ival = 13;

	cout << ival;
	operator<<(cout,ival); /// Global

	cout.operator<<(ival); /// Üye 





	return 0;
}




//////////////////////////////////////////////////////////////



int main(int argc, char const *argv[])
{
	string name1("recep");
	string name2("orhan");

	if (name1 > name2)
		cout << name1 << endl;



	//// if(name1.operator>(name2)) syntax hatası.

	/// Bu şekilde de çağrılabilir.

	if(operator<(name1,name2))
		cout << name1 << endl;



	return 0;
}




//////////////////////////////////////////////////////////////

class Random{
public:
		xxx.operator()();

};

Operatorlerin onceligini degistirmemiz mumkun degildir.


x * y + z Global

operator+(operator*(x,y),z)

Üye Fonksyion
(x.operator*(y)).operator+(z)


int i = 12;
double d = 2.3;

cout << i << d << endl;

((cout.operator<<(i)).operator<<(d)).operator<<(endl)

endl geri donus değeri function pointer 'dır'.






//////////////////////////////////////////////////////////////

class Neco(){

};


Neco operator+(const Neco &r1, const Neco &r2){
	cout << "operator+() cagrıldı " << endl;
}


int int main(int argc, char const *argv[])
{
	Neco n1, n2, n3;

	n1  = n2 + n3;

	return 0;
}


STL''de onemli bir  yer alan iki operator var

operator <
operator ==

Algoritma türden bağımsız template edilmiş fonksiyonlar algoritym kütüphanesi.
#include <set>

using namespace std;

class Neco{

};


int main(int argc, char const *argv[])
{
	set<Neco> myset;
	Neco myneco;

	myset.insert(myneco);
	return 0;
}

//////////////////////////////////////////////////////////////
Friend Bildirimi

Bir sınıf global bir fonksiyona arkadaşlık verebilir.
Bir sınıf bir başka sınıfın bir üye fonksiyonuna arkadaşlık verebilir.


class Neco {
	int mx;
public:
	//friend func(int , int);  /// bir sınıf kendi fonksiyonuna friendlik veremez.


};

int func(int a, int b){
	Neco myNeco ; 
	myNeco.mx = 10;
}

class Gurkan{
public:
	void func();
};




class Neco{
	int mx;
public:
	friend class Gurkan;
};

//////////////////////////////////////////////////////////////


Ön ek Son ek overloading

class Date{

public:
	Date &operator++(); /// Parametre değişkeni olmayan önek
	Date operator++(int);	/// parametre değişkeni olan sonek
int main(int argc, char const *argv[])
{
	Date mydate;
	mydate++;



	return 0;
};

//////////////////////////////////////////////////////////////

Binary simetrik işlemler global operator fonknsyionu ile
Unary işlemler üye operator fonksyionu ile
Olmayan operator overload edilemez
Statik üye fonksyion olamazlar.
Fonksyion çağrı operatoru hariç varsayılan argüman alamaz.
Operatör önceliği değiştirilemez.
İstediğim her fonksyionu global operator fonksyionu oalrak yazamam. global olarak overload edilmez. Üye olmak zorunda.
Operatör fonksiyonuun isimleri keyfi olarak seçilemez .
Operator ++ için dummy int kullanılır.

Const 'luk ' özellikle STL de hata almamıza sebep oolabilir unutulduğu zaman
Ortada bir neden yoksa call by value yapmayın, call by reference yapın.


//////////////////////////////////////////////////////////////
//
// Created by Gurkan Yilmaz on 04/07/15.
//

#pragma once;
class Myint{
    public Myint(int = 0);
    bool operator<(const Myint &)const;
    friend bool operator <(const Myint &, const Myint &);
    friend bool operator <=(const Myint &, const Myint &);
    friend bool operator >(const Myint &, const Myint &);
    friend bool operator >=(const Myint &, const Myint &);
    friend bool operator ==(const Myint &, const Myint &);
    friend bool operator !=(const Myint &, const Myint &);

    friend Myint operator+(const Myint&, const Myint &);
    friend Myint operator-(const Myint&, const Myint &);
    friend Myint operator/(const Myint&, const Myint &);
    friend Myint operator*(const Myint&, const Myint &);
    friend Myint operator%(const Myint&, const Myint &);

    Myint &operator+=(const Myint &r)
    Myint &operator-=(const Myint &r)
    Myint &operator*=(const Myint &r)
    Myint &operator/=(const Myint &r)


    Myint &operator++();
    Myint operator++(int);
    
    Myint &operator--();
    Myint operator--(int);
};


bool operator<(const Myint &, const Myint &);
//  Normal int de çalışmasının sebebi conversion constructor.


C dilinde önek ++ l-value değildir.

C++ l-value'dür'


Tür dönüştürme operatör fonksiyonu

friend Myint operator+(const Myint &r1, const Myint &r2)
{
	Myint retval(r1);
	retval += r2;
	return retval;


	return Myint(r1) += r2;

}


class Myclass{

	operator int()const;
}


operator int()const{ return mval; }
int x;
myintt 


Fraction Sınıfı

fraction.h
#pragma once
#include <iospwd>

class Fraction /// Bir rasyonel sayıyı temsil ediyor. 
{
	Fraction &simplify(); /// Ortak bölenlerinin en büyüğünü bulan bir fonksyiona ihtiyaç var.



public:
	Fraction(int nom = 0, int demom = 1);
	/// F nesnesi dosyaya yazdırılacak -5/7 yazdırırken kesirde olacak eksi
	/// Yazdırırken sadeleştiricek.
	friend bool operator<(const Fraction &r1 , const Fraction &r1); 
	friend bool operator<=(const Fraction &r1 , const Fraction &r1); 
	friend bool operator>(const Fraction &r1 , const Fraction &r1); 
	friend bool operator>=(const Fraction &r1 , const Fraction &r1); 
	friend bool operator==(const Fraction &r1 , const Fraction &r1); 
	friend bool operator!=(const Fraction &r1 , const Fraction &r1); 


	friend Fraction operator+(const Fraction &r1, const Fraction &r2);
	friend Fraction operator-(const Fraction &r1, const Fraction &r2);
	friend Fraction operator*(const Fraction &r1, const Fraction &r2);
	friend Fraction operator/(const Fraction &r1, const Fraction &r2);

	Fraction &operator+=(const Fraction &r);
	Fraction &operator-=(const Fraction &r);
	Fraction &operator*=(const Fraction &r);
	Fraction &operator/=(const Fraction &r);

	Fraction &operator++();
	Fraction operator++(int);
	Fraction &operator--();
	Fraction operator--(int);

	friend std::ostream &operator<<(std::ostream &, const Fraction &);
	friend std::istream &operator>>(std::istream &, const Fraction &);




	static int gcd(int a, int b);
	static Fraction rand();

	int nominator()const;
	int denominator()const;

};


Köşeli parantez operatör fonksiyonu
Fonksiyon çağrı operatör fonksiyonu
İçerik operatör fonksiyonu
Ok operatör fonksiyonu

Köşeli parantez operatör fonksiyonu
Fonksiyon çağrı operatör fonksiyonu
İçerik operatör fonksiyonu
Ok operatör fonksiyonu


/// Köşeli ayraç işlevini yükleyen işlev

Sınıfın üye işleviyle yüklenebilir.
a.operator[](b);
Genellikle bir referans türüne geri döner. Böylelikle işlev çağrı ifadesi doğrudan
bir nesne olarak kullanılabilir.

class Array{
	int *m_p;
	size_t m_size;
public:
	Array(int size = 0 ; int val = 0);
	~Array();
	int operator[](int) const;
	int &operator[](int);
};

Array::Array(int size, int val){
	m_size = size;
	if(m_size == 0){
		m_p = 0;
		return;
	}

	m_p = new int[m_size];
	for(int k = 0 ; k < m_size ; ++k)
		m_p[k] = val;
}

Array::~Array(){
	delete [] m_p;
}

int Array::operator(int index)const{
	return m_p[index];
}


#include <iostream>

int main(){
	Array a(20);
	const Array ca(10,1);
	a[3] = 5;
	// ca[2] = 10; Gecersiz
	std::cout << ca[5] << std::endl;

	return 0;

}


a.operator[](3) = 5;



Fonksyion Çağrı Operatörü Overload
#include <iostream>
using namespace std;

class Distance{
private:
	int feet;
	int inches;
public:
	Distance(){
		feet = 0;
		inches = 0;
	}
	Distance(int f , int i){
		feet = f;
		inches = i;
	}

	Distance operator()(int a, int b,int c){
		Distance D;
		D.feet = a + c + 10;
		D.inches = b + c + 100;
		return D;
	}

	void displayDistance(){
		cout << "F: " << feet << "I:" << inches << endl;
	} 

};


int main(){
	Distance D1(11,10), D2;

	cout << "First Distance";
	D1.displayDistance();

	D2 = D1(10,10,10);
	cout << "Second Distance" ; 
	D2.displayDistance();

	return 0;
}


Köşeli parantez Overload

using namespace std;
const int SIZE = 10;

class safearay{
private:
	int arr[SIZE];
public:
	safearay(){
		int i;
		for(i = 0 ; i < SIZE ; i++){
			arr[i] = i;
		}
	}

	int &operator[](int i){
		if(i > SIZE){
			cout << "Index out of bounds" << endl;
			return arr[0];
		}
	}

	return arr[i];

};



int int main(int argc, char const *argv[])
{
	safearay A;

	cout << "Value of A[2]" << A[2] << endl;
	cout << "Value of A[5]" << A[5] << endl;
	cout << "Value of A[12]"<< A[12]<< endl;
	return 0;
}



Ok operatör fonksiyonu Overload
Üye fonksiyon olmak zorunda return tipi pointer yada nesne olmalı
Smart pointer 
class Ptr{

	X * operator->();
};

#include <iostream>
#include <vector>

using namespace std;
class Obj{
	static int i, j;
public:
	void f() const{cout << i++ << endl; }
	void g() const { cout << j++ << endl; }

};


int Obj::i = 10;
int Obj::j = 12;

class ObjContainer{
	vector<Obj* obj> a;
public:
	void add(Obj* obj){
		a.push_back(obj);
	}

	friend class SmartPointer;
};

class SmartPointer{
	ObjContainer oc;
	int index;
public:
	SmartPointer(ObjContainer& objc){
		oc = objc;
		index = 0;
	}

	bool operator++()//Prefix version
{
	if(index >= oc.a.size())
		if(oc.a[++index] == 0)
			return true;
}

// Overload Operator
Obj* operator->() const{
	if(!oc.a[index]){
		cout << "Zero Value";
		return (Obj*)0;
	}
	return oc.a[index];
}
};




//////////////////////////////////////////////////////////////

#include <>


class Date{
	int m_total_days;
	int m_day, m_mon, m_year;
	static const int mscYearBase = 1700;
	static bool isleap(int y);
	bool isleap()const;

public:
	Date(int d = 0 ,int m = 0 ,int y = 0 );
	//////

	friend bool operator<(const Date &r1, const Date &r2);
	friend bool operator<=(const Date &r1, const Date &r2);
	friend bool operator>(const Date &r1, const Date &r2);
	friend bool operator>=(const Date &r1, const Date &r2);


	Date operator-(int ndays)const;

	friend int operator-(const Date &, const Date &);
	Date &operator++();
	Date operator++(int);
	Date &operator--();
	Date operator--(int);
	operator+=(int ndays);
	operator-=(int ndays);



	Date &setMonthDay(int mday);
	Date &setMonth(int mon);
	Date &setYear(int year);



	////Inserter ve extractorlar

	friend std::ostream &operator<<(std::ostream &, const Date &);
	friend std::istream &operator>>(std::istream &, Date &);

	static Date random();

	int getYear()const;
	int getMonth()const;
	int getMDay()const;
	int getWeekDay()const;  /// 
	int getYearDay()const;
};


throw BadDate();
class BadDate{};

int int main(int argc, char const *argv[])
{
	Date date1;
	Date date2(13);
	Date date3(25,04);
	Date date4(1,1,1998);
	Date.date5 =  Date::random();

	if(date5 > date1){
		date1--;
	}
	else
		date2 = ++date1;

	if(date2 - date3 > 300){
		date1 += 100;
	}

	cout << date2 + 125 << endl;



	return 0;
}


//////////////////////////////////////////////////////////////
İnterface hafif olmalı gerektiğinden dolu olmamalı
//////////////////////////////////////////////////////////////

içerik operatör fonksiyonu 

int main(){

	list<int>::iterator iter = mylist.begin(); ///// geri dönüş değeri list<int>::iterator ? 

	auto iter = mylist.begin();

	İçerik operatörünün operandı yaparsak o konumdaki nesneye erişicel.
	cout << *iter << endl;

	++iter;

	range başlangıç ilk öğe fakat bitiş son+1 . nci öğedir!!!


	for(auto iter = mylist.begin() ; iter != mylist.end() ; ++iter)
		;

	mylist.reverse();





}


İçerik operatörünün overload edilmesi :

Fonksiyonun geri dönüş değeri nesneye dönmesi için geri dönüş değeri referans olmalı.


int main(int argc, char const *argv[])
{
	SmartPtr ptr = new Class;

	(*ptr).display();
	(*ptr).set(346);
	Myclass m{45};
	m = *ptr;




	return 0;
}

Smartpointer'lar' kısmi manada garbage collector işlevinin yerine getirilmesine yardımcı olur.

//////////////////////////////////////////////////////////////
Template'ler'
Şablona dayalı kod yazdırımı


template<typename T, int size>  




template<typename T>   /// T herşey olabilir.
class SmartPtr{
	T *mp;
public:
	SmartPtr(T *p): mp (p);
	~SmartPtr(){
		delete mp;
	}
	T &operator*(){return *mp};
	T *operator->(){return mp};


};


template<typename T>
class List{

};
int main(int argc, char const *argv[])
{
	SmartPtr<Myclass> ptr = new Myclass;
	SmartPtr<string> p = new string;
	list<int> mylist;







	return 0;
}






//////////////////////////////////////////////////////////////
template<typename Key, typename Value>
class Map{

};


int main(int argc, char const *argv[])
{
	Map<int,double> x;

	return 0;
}



template<typename Elem, int size>


class Array{
	Elem a[size];

};



int main(int argc, char const *argv[])
{
	Array<int,30> x;
	return 0;
}

//////////////////////////////////////////////////////////////

using namespace std:
class Myclass{
public:
	bool operator()(int) // unary predicate
};

Predigate sınıf

void operator()(){
	cout << "Myclass::operator()()" << endl;
}

class Random{
	int mlow,mhigh;
public:
	Random(int low, int high) : mlow(low),mhigh(high){}
	int operator()(){return rand % (mhigh-mlow +1) + mlow;}
};



//////////////////////////////////////////////////////////////
using namespace std;
#include <algoritym>

bool isok(int val){
	return val % 5 == 0;
}

template<typename T, class U>
void Countif(,, , , , , , , , U x){
	if( x())
}




class Unpred{
int mx;
public:
	Unpred(int val) : mx{val}{}
	bool operator()(int x){return x % mx == 0; }


};
int main(int argc, char const *argv[])
{
	list<int> mylist;

	srand(static_cast<unsigned>(time(nullptr)));
	for(int k = 0 ; k < 1000 ; k++)
		mylist.push_back(rand());

	count_if(mylist.begin, mylist.end, &isok);

	return 0;
}

//////////////////////////////////////////////////////////////

#include <iostream>
#include <string>
#include <list>
#include <ctime>
#include <cstdlib>
#include <algorithm>

using namespace std;

class Inta{
	int *mp;
public:
	Inta(size_t size) : mp{new int[size]}{

	}; 
	~Inta(){ delete[]mp;}

	////
};

Inta getArray(){
	///,
	int x = 500;
	Inta retval(x);

	return retval;
}


int main(int argc, char const *argv[])
{
	int size;
	cin >> size;

	Inta a(size);

	return 0;
}

int main(int argc, char const *argv[])
{
	Inta myarray = getArray();

	return 0;
}




//////////////////////////////////////////////////////////////

Sağ Taraf referansı taşıma ve mükemmel gönderim de kullanılmak üzere oluşturulmuş bir araçtır.

Atama operatörünün sol tarafına gelen ifadelere sol taraf değeri gelemeyenlere sağ taraf referansı denir.
Adres operatörünün operandı olabilen ifadelere sol taraf referansı , olamayanlar sağ taraf referansı denir.

int x = 20;
int y = 56;

x ve y  l value

x+y R value

345 R value;

func() R value;
&func() --> error


R value ---> &&r
L value ---> &r


------------------------------------------------------------------------------
int &r = 5 // Error

------------------------------------------------------------------------------
int func();

int &r = func(); // Error
------------------------------------------------------------------------------

Sol taraf değeri sağ taraf referansına verilemez.
-------------

int x = 45;
int &&r = x; // Error
int &&r = 56; // Sağ taraf değeri sağ taraf referansına bağlanmış sıkıntı yok.

------------------------------------------------------------------------------

int func();

int &&r = func();

int &func();
int &&r = func(); /// Error 

------------------------------------------------------------------------------

void func (int &r); /// Sol taraf referansı
void func(int &&r); /// Sağ taraf referansı Function Overloading




class Inta{};

void func(Inta &r);
void func(Inta &&r);

---------------------------------------

void func(int &r){
	cout << "L value" << endl;
}
void func(int &&r){
	cout << "R value" << endl;
}


Amaç function overloading de farklılık yaratım Deep copy yapılırken mmove semantiğinin kullanılmasına olanak vermek.
---------------------------------------------------------------------------------------------------------------------

Sağ taraf refenrası seçilerek exact match olur.

using namespace std;


class Myclass{
public:
	Myclass(const Myclass &r);  /// Copy constructor.
	Myclass(Myclass &&r);		/// Move Constructor

};





int main(int argc, char const *argv[])
{
	

	return 0;
}


---------------------------------------------------------------------------------------------------------------------

class Vector{
	int m_size;
	int *m_p;
public:
	Vector(int size) : m_size (size), mp(new int [size]){}
	Vector(const Vector &r) : m_size(r.m_size){
		m_p = new int [m_size];
		for(int k = 0  ; k< m_size; k++){
			m_p[k] = r.m_p[k];
		}
	}
	Vector(Vector &&r) : m_p(r.m_p), m_size(r.m_size){
		r.m_p = nullptr;
	}

};




int main(int argc, char const *argv[])
{
	Vector vec(565);
	vec = getVector();


	return 0;
}

Vector &operator=()


/////////////////////////////////////////////////////////////

Association 
Aggregation Sahiplik
Composition Ömürsel

Araba araba motoru ilişkisi composition -> araba varsa motor var araba yoksa motor yok. /// Ömürsel birliktelik

Bir sınıfın veri elemanını doğrudan başka bir sınıf elemanı olması.
1-Elemanı dpğrudan almak
2-Elemanı conmstructor la alıp destructor la destruck etmek.


//////////////////////////////////////////////////////////////


using namespace std;

class Engine{
public:
	Engine(){
		cout << "Engine::Engine"<< endl;
	}
};


class Car{
	Engine m_e;

};


int main(int argc, char const *argv[])
{
	Engine e;

	return 0;
}


Bir sınıfın tanımı olmadan kullanılması durumuna incomplete type.
ama class Engine *e; pointer ile erişim sonucu error olmaz.

class 











//////////////////////////////////////////////////////////////

#pragma once

class Student{
	std::string m_name;
};


class TeachingGroup{
	std::vector<std::string> mvec;
};


Pointer yada referans olsa idi böyle bir zorunluluk olmayacaktı.
//////////////////////////////////////////////////////////////

#include <vector>
#include <string>

using namespace std;

int main(int argc, char const *argv[])
{
	vector<string> svec;

	
	string s("murat arman");
	svec.push_back(s);
	svec.push_back(move(s));

	return 0;
}

-----------------------------------------------------------


class Member {
public:
	Member &operator=(const Member &){
		cout << "Member::operator(const Member &)" << endl;
		return *this;
	}
};

class Owner{
	Member mem;
};

int main(int argc, char const *argv[])
{
	Owner x, y;
	x = y;

	return 0;
}

class Sina{
public:
	Sina(int);
};

class Myclass{
	Sina mx { 5 };
public: 
};

int main(int argc, char const *argv[])
{
	Myclass a;
	return 0;
}



//////////////////////////////////////////////////////////////
vector<int> Myclass::ivec{100,12};





using namespace std;

class Myclass{
	class StaticData{
		std::vector<int> ivec1;
		std::vector<int> ivec2;
	};
	static StaticData ms_instance;
public:

};

Myclass::StaticData Myclass::ms_instance;
int main(int argc, char const *argv[])
{
	
	return 0;
}

Nested Types

class Myclass{
public:
	typedef int Color;

};

void Myclass::func(){
	Color mycolor;
}

int main(int argc, char const *argv[])
{
	Myclass::Color m;

	return 0;
}

//////////////////////////////////////////////////////////////

class Myclass{
	Color mx; /// İsim aramada bulunamaz Error!
	typedef int Color;
public:
};

class Myclass{
	class Iterator{

	};
	Iterator m_iter;
public:

};
	
------------------------------------------------		
myclass.h

class Myclass{
	class Color;
public:

};

myclass.CPP

class Myclass::Color{
public:
	Color();

};

Myclass::Color::Color();

--------------------------------------------------

myclass.h



class Myclass{

};



//////////////////////////////////////////////////////////////

//// Myclass.h
class Myclass{
	struct Pimple;
	Pimple *mp;
public:
	Myclass();
	~Myclass();
	void display()const;
};


//Cpp

struct Myclass::Pimple{
	int mx, my;
	Pimple() : mx(0),my(0){}
};


Myclass::~Myclass(){
	delete mp;
}

Myclass::Myclass():mp{new Pimple}{}

void Myclass::dislay()const{
	mp->mx;
	mp->my;
}




//////////////////////////////////////////////////////////////

#include <vector>
#include <iostream>


using namespace std;

int main(int argc, char const *argv[])
{
	vector<int>::size_type
	vector<int>::iterator x;

	vector<int>::iterator::iterator_category //// Nested sınıf iterator , Typedef iteratorCategory




	return 0;
}




class Vector{
public:
	class Iterator{
	public:
		typedef int iterator_category;
	};
};


int main(int argc, char const *argv[])
{
	Vector::Iterator::iterator_category
	return 0;
}

Konu Başlıkları
String Sınıfı
Kalıtım 
Ezoterik Araçlar
OOP Genel Araçlar
STL
Dosyalar Giriş Çıkış İşlemleri 


Belki Regex, Smart Pointer, Thread vs.


//////////////////////////////////////////////////////////////

String Sınıfı

typedef basic-string<char> string
String tipi aslında bir typedef ismi
char-traits<char>

String dediğimiz sınıfın tam tür ismi :: 

typedef basic_string<char, char_traits , allocator> string

#include <string> // C++
#include <cstring>// C

using namespace std;

int main(int argc, char const *argv[])
{
	
	return 0;
}
C++ 2011 le beraber Regex kütüphanesi de dahil edildi.
Bazı yazı işlemleri STL algoritym kütüphanesi ile yapılır.
Sınıfın önemli bir bölümü operatör overloading işlemlerinden oluşuyor.

Bazı karışık işlemler STL le kolay bir şekilde halledilebilir.
//////////////////////////////////////////////////////////////
size isimli üye fonksyionu konteynır da tutulan eleman sayısını verir.
string size dersek string in harf sayısını verir.

string::size_type ///İçsel tür // yazının uzunluğunun türü

string::size_type len = s.length();
auto len = s.length();


size_t nin karşılığı aslen string::size_type


string s;

cout << s.size() << endl;
cout << s.length() << endl;
s.empty();   == s.size()


İki fonskiyonda yazının uzunluğunu vermektedir.

//////////////////////////////////////////////////////////////

string s1("mustafa"); 	//const char * constructor;
string s2 = "gurkan";
string s3{ "mehmet" };  //C++11

string s1(12, 'A');  ///// 12 adet A eklenir.  Bir parametre size_type diğeri char

cout << "(" << s1 << ")" << endl;

 

string s1(s2); /// Copy Constructor



string s('A'); /// boyle bir char parametreli constructor mevcut değil.
bunun alternatifleri 	string s1(1,"A");
						string s1("A");

parametresi char olan atama operatör fonksiyonu var ama parametresi char olan string constructor yok.

string s1("Nurettin");
string s2(s1 , 3); /// s1 in 3 indeksinden başlayarak

cout << "(" << s2 << ")" << endl;  //ettin

string s2(s1 , 3 , 2);  // et


char str[100] = "mustafa";

string s1(str); ///const char * lı constructor
string s2(str , 5);  ///char * ve size_type parametreli bir constructor mevcut.



string s1(str+1, str + 5);  //Range based constructor for array

string s1("sina dogru");

string s2(s1.begin , s1.begin() + 4)  /// range based constructor for string container

Initializer List

vector<int> ivec({12 , 45 , 67 , 89 });

string s({ 'a' , 'b' });
s.insert(1, { 'c' , 'a'} );


Listedeki parametrelerin tamamı kullanılıyor.



string func();


string s1("seyfettim");

string s2(move(s1));  ////Move constructor.

string h_em(const string &r);
{
	return "<em>" + r + "/em";
}

Stringi fonksyiona geçerken ideal olan referans göndermek.


#include <list>

int main(int argc, char const *argv[])
{
	list<char> mylist;
	mylist.push_back('c');
	mylist.push_back('a');
	mylist.push_back('n');


	string s(mylist.begin(), mylist.end);


	cout << s << endl;


	return 0;
}


//////////////////////////////////////////////////////////////

string s(120 , 'A' );

cout << s.capacity() << endl;

string s;
string ::size_type cap = 0;
for (int k = 0 ; k < 10000 ; ++k)}
{
	s.push_back('A');
	if(s.capacity() != cap ){
		cout << "size = " << s.size() << endl;
		cout << "capacity" << s.capacity() << endl;
		cap = s.capacity();
		getchar();
	}
}

//////////////////////////////////////////////////////////////

string s;

s.reserve(120);

s[5] = 'A';  //// runtime hatası
//////////////////////////////////////////////////////////////

string s(2345, 'x');

s.reserve(200)  ///Yapılamaz kapasite büyür , kapasite küçülmez.
s.clear(); /// butun elemanları sıfıra çeker.
s.erase(); /// Butun elemanları sıfıra çeker.
s.reserve() //Fonksiyonu çağırılarak kapasite büzülmesi istenebilir fakat garantili değildir.İmplimentasyon kabul ederse olabilme ihtiyacı var.
s.shrink_to_fit();  //Daha garantili 

//////////////////////////////////////////////////////////////

Elemanlara erişmek

[] ve At fonksyionu

string s("orhankaya");


for (int k = 0 ; k < s.size() ; k++ )
	cout << s[k] << " ";

cout << endl;

s[5]  = 'X';
s[8] = 'Z';


cout << s << endl;



s.at(k);  //// Farkı exception throw eder.

exception throw ederken r.what(); fonksiyonu hatanın ne olduğu hakkında bilgi verir.


string s("orhan");
(int) s[s.size()] //// C++11 ile birlikte null karaktere ulaşma garantisi var , at de bu yok.

//////////////////////////////////////////////////////////////


s.front() = 'X'; // C++11   
s.back() = 'X';  // C++11


////begin() , end() iterator donduren islevler
////front() , back() ilk ve son öğreye eriştiren işlevler



cout << s << endl;

return 0; 



npos değeri static const bir veri elemanı string sınıfının

class string {
public:
	const static size_type npos;

};


Statik veri elemanına herzaman :: ile ulaş

string::npos // işaretsiz bir tamsayıdır
string s("murat aksoy");
auto idx = s.find('a');
string size_type idx = s.find('a');

if(idx == string::npos)
	cout << "bulunamadi" << endl;


Bütün arama fonksiyonlarının geri dönüş değeri doğru olması npos 'uyla' alaka
Arama fonksiyonun geri dönüş değeri npos a eşit ise bulunup bulunamamsıdır.



template <typename T , typename U = char_traits<T>, typename A = allocator<T>>
class basic_string{

};

String sınıfının template açılımı

npos arama işlemleri ve geri kalan karakterlerinin hepsinin alınmasında kullanılması.


s.append
s.assign
s.at
s.front
s.back
s.begin
s.capacity
s.cbegin
s.cend
s.clear
s.reverse



string s("murat aksoy");

cout << s[0] << endl;

*s.begin();
*s.end;


string::iterator iter1 = s.end();
string::iterator iter2 = s.begin();



int main(int argc, char const *argv[])
{
	string s("recepmutlu");
	sort(s.begin,s.end); //kucukten buyuge sorgular

	cout << s << endl;
	cout 
	return 0;
}



int main(int argc, char const *argv[])
{
	vector<string> svec{"orhan" , "necat", "emre" ,"ozkan"};

	sort(svec.begin(),svec.end()
	return 0;
}




*max_element(s.begin(),s.end())  max element iterator dondurmekte dondurdugu elemana erişmek için içerik operatörünü kullanmak gerekir.
okuma amaçlı yapılan işlemlerde 
cbegin
cend fonksiyonları kullanılabilir.
rbegin
rend fonksiyonları algoritmaların sondan başa doğru çalıştırılmasına izin veriyor.





reverse iterator  aracı ile algoritmaları kullanırken tersten yazdırabiliriz.

using namespace std;

template <typename Iter>
void DisplayRange(Iter beg, Iter end){
	while (beg != end)
		std::cout << *beg++;
	std::cout << endl;
} 


int main(int argc, char const *argv[])
{
	/* code */
	return 0;
}


s.substr() // Parametresiz hali stringin tamamını döndürmektedir.
s.substr(8) //8. elemandan itibaren kalan bütün char lar







int main(int argc, char const *argv[])
{
	string filename;

	cout << "dosya ismi:";
	cin >> filename;

	auto idx = filename.rfind('.');

	if(idx == string::npos){
		cout << "dosya uzantisi yok" << endl;

	}



	else{

	}
	return 0;
}


Resize container larda kapasiteyi değil karakter kapasitesini ayarla.


int main(int argc, char const *argv[])
{
	string s("ali");

	s.resize(8 , 'x');

	s.resize(2);  /// Kucultme islemi


	return 0;
}


lexicographical_compare

container compare

karşılaştırma operator fonksyionlarının char paramtresi yok.


string name{"necatiergin"};
name.compare(3, 3, "atil" , 3);


insert fonksiyonu
Geri dönüş değeri insert edilen fonksiyonun yeri


svec.insert(svec.begin , "murat");


index ile set edilen nesnelerin ger dönüş değeri stringin kendisini



string s1{"gurkan"};
string s2{"xyz"};

s1.insert(3 , s2);   ////gurkxyzan
s1.insert(s1.begin(), 10 , 'x');

.erase( iterator ) O konumda olan elemanı siler.
.erase( beg , end) o aralıktaki elemanları siler.

stringleri silme:
string s{"recepmutlu"};
s="";
s.resize(0);

s.erase(s.begin()+ 3 , s.begin +5);
Replace fonksiyonu

Data fonksiyonu

#include <string.h>


using namespace std;
int main(int argc, char const *argv[])
{
	int x;
	string base{"image"};

	to_string() fonksiyonu ile stringe istenilen tür çevrilebilir.

	return 0;
}

Yazının içinden tamsayıyı çekmek

int main(int argc, char const *argv[])
{
	string s("2345Ali");
	size_t uval;


	auto x = stoi(s, &uval);
	cout << x << endl;
	cout << uval << endl;

	return 0;
}


Inheritance ( Türetme )




















	